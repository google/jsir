// Copyright 2024 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#ifndef MALDOCA_ASTGEN_AST_GEN_H_
#define MALDOCA_ASTGEN_AST_GEN_H_

#include <string>
#include <vector>

#include "absl/strings/string_view.h"
#include "maldoca/astgen/ast_def.h"
#include "maldoca/astgen/symbol.h"
#include "maldoca/astgen/type.h"
#include "google/protobuf/io/printer.h"
#include "google/protobuf/io/zero_copy_stream.h"

namespace maldoca {

class AstGenPrinterBase : public google::protobuf::io::Printer {
 public:
  explicit AstGenPrinterBase(google::protobuf::io::ZeroCopyOutputStream *os)
      : google::protobuf::io::Printer(os, /*variable_delimiter=*/'$') {}

  template <typename... Args>
  void Println(Args &&...args) {
    Print(std::forward<Args>(args)...);
    Print("\n");
  }

  void Println() { Println(""); }
};

// Printer of the TypeScript interface definition for the AST.
//
// Format:
//
// interface ObjectMember <: Node {
//   key: Expression;
//   computed: boolean;
//   decorators?: [ Decorator ];
// }
class TsInterfacePrinter : AstGenPrinterBase {
 public:
  explicit TsInterfacePrinter(google::protobuf::io::ZeroCopyOutputStream *os)
      : AstGenPrinterBase(os) {}

  // Prints the "ast_ts_interface.generated" file.
  //
  // See test cases in test/ for examples.
  void PrintAst(const AstDef &ast);

  // Prints an enum definition.
  //
  // See test cases in test/ for examples.
  void PrintEnum(const EnumDef &enum_def, absl::string_view lang_name);

  // Prints the class declaration for a node.
  //
  // See test cases in test/ for examples.
  void PrintNode(const NodeDef &node);

  // Prints the definition of a field.
  //
  // Format:
  //  <fieldName>: <js_type>
  //  <fieldName>?: <js_type>
  //
  // - fieldName: Printed as camelCase.
  // - js_type: See `Type::JsType()`.
  //
  // Example:
  //  right: Expression
  //  param?: Pattern
  void PrintFieldDef(const FieldDef &field);
};

std::string PrintTsInterface(const AstDef &ast);

// Common functions for printing C++ code.
class CcPrinterBase : public AstGenPrinterBase {
 public:
  explicit CcPrinterBase(google::protobuf::io::ZeroCopyOutputStream *os)
      : AstGenPrinterBase(os) {}

  // Print Apache license comment.
  void PrintLicense();

  // Example:
  //
  // Input:
  // cc_namespace == "maldoca::astgen"
  //
  // Output:
  // ```
  // namespace maldoca {
  // namespace astgen {
  // ```
  void PrintEnterNamespace(absl::string_view cc_namespace);

  // Example:
  //
  // Input:
  // cc_namespace == "maldoca::astgen"
  //
  // Output:
  // ```
  // }  // namespace astgen
  // }  // namespace maldoca
  // ```
  void PrintExitNamespace(absl::string_view cc_namespace);

  // Example:
  //
  // Input:
  // header_path == "maldoca/astgen/test/lambda/ast.h"
  //
  // Output:
  // ```
  // #ifndef MALDOCA_ASTGEN_TEST_LAMBDA_AST_H_
  // #define MALDOCA_ASTGEN_TEST_LAMBDA_AST_H_
  // ```
  void PrintEnterHeaderGuard(absl::string_view header_path);

  // Example:
  //
  // Input:
  // header_path == "maldoca/astgen/test/lambda/ast.h"
  //
  // Output:
  // ```
  // #endif  // MALDOCA_ASTGEN_TEST_LAMBDA_AST_H_
  // ```
  void PrintExitHeaderGuard(absl::string_view header_path);

  // Example:
  //
  // Input:
  // header_path == "maldoca/astgen/test/lambda/ast.h"
  //
  // Output:
  // ```
  // #include "maldoca/astgen/test/lambda/ast.h"
  // ```
  void PrintIncludeHeader(absl::string_view header_path);

  // Prints headers in alphabetical order by sorting a copy of the header paths.
  void PrintIncludeHeaders(std::vector<std::string> header_paths);

  // Example:
  //
  // Input:
  // title == "BinaryExpression"
  //
  // Output:
  // ```
  // // ========================================================================
  // // BinaryExpression
  // // ========================================================================
  // ```
  void PrintTitle(absl::string_view title);

  // Output:
  // // ========================================================================
  // // STOP!! DO NOT MODIFY!! THIS FILE IS AUTOMATICALLY GENERATED.
  // // ========================================================================
  void PrintCodeGenerationWarning();

  // Some convenient wrappers for printing C++ types.
  std::string CcType(const FieldDef &field) const {
    return field.type().CcType(field.optionalness());
  }

  std::string CcMutableGetterType(const FieldDef &field) const {
    return field.type().CcMutableGetterType(field.optionalness());
  }

  std::string CcConstGetterType(const FieldDef &field) const {
    return field.type().CcConstGetterType(field.optionalness());
  }
};

// Printer of the C++ header for the AST.
class AstHeaderPrinter : public CcPrinterBase {
 public:
  explicit AstHeaderPrinter(google::protobuf::io::ZeroCopyOutputStream *os)
      : CcPrinterBase(os) {}

  // Prints the "ast.generated.h" header file.
  //
  // - cc_namespace: The C++ namespace for all the AST node classes.
  //   Example: "maldoca::astgen".
  //
  // - ast_path: The directory for the AST code.
  //   "ast.generated.h" is in that directory.
  //   This is used to generate the header guard.
  //
  // See test cases in test/ for examples.
  void PrintAst(const AstDef &ast, absl::string_view cc_namespace,
                absl::string_view ast_path);

  // Prints the enum definition and the prototypes of string conversion
  // functions.
  //
  // Example:
  //  enum UnaryOperator {
  //    kMinus,
  //    ...
  //  };
  //
  //  absl::string_view UnaryOperatorToString(UnaryOperator unary_operator);
  //  absl::StatusOr<UnaryOperator> StringToUnaryOperator(absl::string_view s);
  void PrintEnum(const EnumDef &enum_def, absl::string_view lang_name);

  // Prints the class declaration for a node.
  //
  // See test cases in test/ for examples.
  void PrintNode(const NodeDef &node, absl::string_view lang_name);

  // Prints the constructor of a node class.
  //
  // Example:
  //  explicit Variable(std::string identifier)
  //      : Expression(), identifier_(std::move(identifier)) {}
  void PrintConstructor(const NodeDef &node, absl::string_view lang_name);

  // Prints the getter and setter declarations for a field.
  //
  // Format:
  //  <cc_mutable_getter_type> <field_name>();
  //  <cc_const_getter_type> <field_name>() const;
  //  void set_<field_name>(<cc_type> <field_name>);
  //
  // - cc_mutable_getter_type: See `Type::CcMutableGetterType()`.
  // - cc_const_getter_type: See `Type::CcConstGetterType()`.
  // - cc_type: See `Type::CcType()`.
  //
  // Example:
  //  Expression* right();
  //  const Expression* right() const;
  //  void set_right(std::unique_ptr<Expression> right);
  void PrintGetterSetterDeclarations(const FieldDef &field,
                                     absl::string_view lang_name);

  // Prints a member variable declaration.
  //
  // Format:
  //  <cc_type> <field_name>_;
  //
  // - cc_type: The C++ value type. See `Type::CcType()`.
  // - field_name_: We print the name in snake_case and add a '_'.
  //
  // Example:
  //  std::unique_ptr<Expression> right_;
  void PrintMemberVariable(const FieldDef &field, absl::string_view lang_name);

  // Format:
  //  static absl::StatusOr<<cc_type>>
  //  Get<FieldName>FromJson(const nlohmann::json& json);
  //
  // Example:
  //  static absl::StatusOr<std::unique_ptr<Expression>>
  //  GetRightFromJson(const nlohmann::json& json);
  void PrintGetFromJson(const FieldDef &field, absl::string_view lang_name);
};

// Prints the "ast.generated.h" header file.
//
// - cc_namespace: The C++ namespace for all the AST node classes.
//   Example: "maldoca::astgen".
//
// - ast_path: The directory for the AST code.
//   "ast.generated.h" is in that directory.
//   This is used to generate the header guard.
std::string PrintAstHeader(const AstDef &ast, absl::string_view cc_namespace,
                           absl::string_view ast_path);

// Printer of the C++ source for the AST.
class AstSourcePrinter : public CcPrinterBase {
 public:
  explicit AstSourcePrinter(google::protobuf::io::ZeroCopyOutputStream *os)
      : CcPrinterBase(os) {}

  // Prints the "ast.generated.cc" file, which includes the definitions of
  // getters and setters of all the AST node classes.
  //
  // - cc_namespace: A namespace separated by "::".
  //   This is used to print C++ namespaces.
  //
  // - ast_path: The directory for the AST code.
  //   "ast.generated.h" is in that directory.
  //   This is used to print the #include.
  void PrintAst(const AstDef &ast, absl::string_view cc_namespace,
                absl::string_view ast_path);

 private:
  void PrintConstructor(const NodeDef &node, absl::string_view lang_name);

  // Prints the string conversion functions.
  //
  // Example:
  //
  //  absl::string_view UnaryOperatorToString(UnaryOperator unary_operator) {
  //    ...
  //  }
  //
  //  absl::StatusOr<UnaryOperator> StringToUnaryOperator(absl::string_view s) {
  //    ...
  //  }
  void PrintEnum(const EnumDef &enum_def, absl::string_view lang_name);

  // Prints the getters and setters of one AST node class.
  void PrintNode(const NodeDef &node, absl::string_view lang_name);

  // Prints the C++ code that returns a value that's compatible with the types
  // `type.CcMutableGetterType()` and `type.CcConstGetterType()`.
  //
  // `cc_expr` is an lvalue expression of the type `type.CcType()`.
  void PrintGetterBody(const std::string &cc_expr, const Type &type);

  // Prints the C++ code that returns a value that's compatible with the types
  // `type.CcMutableGetterType(is_optional)` and
  // `type.CcConstGetterType(is_optional)`.
  //
  // `cc_expr` is an lvalue expression of the type `type.CcType()`.
  void PrintGetterBody(const Symbol &field_name, const Type &type,
                       bool is_optional);

  // Prints the C++ code that sets one field.
  //
  // `field_name` is an lvalue expression that has the type
  // `type.CcType(is_optional)`. We need to set the field `field_name_`.
  void PrintSetterBody(const Symbol &field_name, const Type &type,
                       bool is_optional);
};

std::string PrintAstSource(const AstDef &ast, absl::string_view cc_namespace,
                           absl::string_view ast_path);

enum class DefOrAssign {
  // Define a variable of the exact same type.
  kDef,

  // Assign to an existing variable of a compatible type.
  kAssign,
};

// Printer of the C++ Serialize() function for the AST.
class AstSerializePrinter : public CcPrinterBase {
 public:
  explicit AstSerializePrinter(google::protobuf::io::ZeroCopyOutputStream *os)
      : CcPrinterBase(os) {}

  void PrintAst(const AstDef &ast, absl::string_view cc_namespace,
                absl::string_view ast_path);

 private:
  // Print*Serialize()
  //
  // Prints either:
  // - An assignment "<lhs> = ConvertSerialize(<rhs>);", or
  // - A variable definition "nlohmann::json <lhs> = ConvertSerialize(<rhs>);"
  //
  // - lhs: If printing an assignment, an lvalue expression of type
  //        nlohmann::json; if printing a variable definition, the name of that
  //        variable.
  // - rhs: An expression of type `type.CcType()`.
  void PrintBuiltinSerialize(const BuiltinType &type,
                             const std::string &lhs,
                             const std::string &rhs);

  void PrintEnumSerialize(const EnumType &type,
                          const std::string &lhs,
                          const std::string &rhs,
                          absl::string_view lang_name);

  void PrintClassSerialize(const ClassType &type,
                           const std::string &lhs,
                           const std::string &rhs);

  void PrintVariantSerialize(const VariantType &variant_type,
                             const std::string &lhs,
                             const std::string &rhs,
                             absl::string_view lang_name);

  void PrintListSerialize(const ListType &list_type,
                          const std::string &lhs,
                          const std::string &rhs,
                          absl::string_view lang_name);

  void PrintSerialize(const Type &type, const std::string &lhs,
                      const std::string &rhs, absl::string_view lang_name);

  void PrintNullableToJson(const Type &type, MaybeNull maybe_null,
                           const std::string &lhs, const std::string &rhs,
                           absl::string_view lang_name);

  void PrintSerializeFieldsFunction(const NodeDef &node,
                                    absl::string_view lang_name);

  void PrintSerializeFunction(const NodeDef &node,
                              absl::string_view lang_name);

  void PrintSerializeFunctionOverload(const NodeDef &node,
                                      absl::string_view lang_name);
};

// Prints the "ast_to_json.generated.cc" source file.
//
// - cc_namespace: The C++ namespace for all the AST node classes.
//   Example: "maldoca::astgen".
//
// - ast_path: The directory for the AST code.
//   "ast.generated.h" is in that directory.
//   This is used to print the #include.
std::string PrintAstToJson(const AstDef &ast, absl::string_view cc_namespace,
                           absl::string_view ast_path);

class AstFromJsonPrinter : public CcPrinterBase {
 public:
  explicit AstFromJsonPrinter(google::protobuf::io::ZeroCopyOutputStream *os)
      : CcPrinterBase(os) {}

  void PrintAst(const AstDef &ast, absl::string_view cc_namespace,
                absl::string_view ast_path);

  void PrintTypeChecker(const NodeDef &node);

  void PrintBuiltinJsonTypeCheck(const BuiltinType &type, const Symbol &rhs);

  void PrintClassJsonTypeCheck(const ClassType &class_type, const Symbol &rhs);

  // ===========================================================================
  // Print*FromJson()
  // ===========================================================================
  //
  // Prints the code that converts a nlohmann::json variable `rhs` to a C++
  // value of the type `type.CcType()`.
  //
  // `rhs` is guaranteed to be non-null.
  // However, the type of `rhs` is unknown and might not match `type`.
  // We need to print type-checking code before the actual conversion.
  //
  // Action
  // ======
  //
  // - Def:
  //
  //   Defines a variable with name `lhs` and type `type.CcType()`.
  //   Stores the conversion result.
  //
  // - Assign:
  //
  //   Assigns the conversion result to `lhs`, which is an existing variable.
  //   The type of `lhs` is not `type.CcType()`, but you can assign a value of
  //   `type.CcType()` to it.
  //
  //   This is fine with scalar types.
  //   Consider the following example:
  //    nlohmann::json rhs = ...;
  //    std::optional<std::string> lhs = ...;
  //
  //    // Generated code starts here:
  //    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~
  //    // ... Checks that `rhs` is a JSON array ...
  //    lhs = rhs.get<std::string>();  // This assignment is okay.
  //
  //   However, this is troublesome with list type.
  //   Consider the following example:
  //    nlohmann::json rhs = ...;
  //    std::optional<std::vector<std::string>> lhs = ...;
  //
  //    // Generated code starts here:
  //    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~
  //    // ... Checks that `rhs` is a JSON array ...
  //    for (const nlohmann::json& rhs_element : rhs) {
  //      std::string lhs_element = ...; // Convert from rhs_element.
  //      // Oh awkward - we can't do "lhs.push_back(...)".
  //    }
  //
  //   Therefore, for lists, we need to create a new variable `lhs_value` and
  //   assign it to `lhs` in the end. Like this:
  //    nlohmann::json rhs = ...;
  //    std::optional<std::vector<std::string>> lhs = ...;
  //
  //    // Generated code starts here:
  //    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~
  //    // ... Checks that `rhs` is a JSON array ...
  //    std::vector<std::string> lhs_value;
  //    for (const nlohmann::json& rhs_element : rhs) {
  //      std::string lhs_element = ...; // Convert from rhs_element.
  //      lhs_value.push_back(std::move(lhs_element));
  //    }
  //    lhs = std::move(lhs_value);
  //
  // - Return:
  //
  //   Returns the conversion result.
  enum class Action {
    kDef,
    kAssign,
    kReturn,
  };

  // CheckJsonType - Whether to print the JSON type check code.
  //
  // This is a special case for BuiltinType.
  // In all other cases we always print the type check.
  enum class CheckJsonType {
    kYes,
    kNo,
  };

  void PrintBuiltinFromJson(Action action, CheckJsonType check_json_type,
                            const BuiltinType &builtin_type, const Symbol &lhs,
                            const Symbol &rhs);

  void PrintEnumFromJson(Action action, const EnumType &enum_type,
                         const Symbol &lhs, const Symbol &rhs,
                         absl::string_view lang_name);

  void PrintClassFromJson(Action action, const ClassType &class_type,
                          const Symbol &lhs, const Symbol &rhs,
                          absl::string_view lang_name);

  void PrintVariantFromJson(Action action, const VariantType &variant_type,
                            const Symbol &lhs, const Symbol &rhs,
                            absl::string_view lang_name);

  void PrintListFromJson(Action action, const ListType &list_type,
                         const Symbol &lhs, const Symbol &rhs,
                         absl::string_view lang_name);

  void PrintFromJson(Action action, const Type &type, const Symbol &lhs,
                     const Symbol &rhs, absl::string_view lang_name);

  // Same as PrintFromJson, but:
  //
  // - The nullness of `rhs` is not guaranteed. We need to print the nullness
  //   check code.
  //
  // - Instead of `type.CcType()`, the output type is `type.CcType(maybe_null)`.
  void PrintNullableFromJson(Action action, const Type &type,
                             MaybeNull maybe_null, const Symbol &lhs,
                             const Symbol &rhs, absl::string_view lang_name);

  void PrintGetFieldFunction(const std::string &node_name,
                             const FieldDef &field,
                             absl::string_view lang_name);

  void PrintFromJsonFunction(const NodeDef &node, absl::string_view lang_name);
};

std::string PrintAstFromJson(const AstDef &ast, absl::string_view cc_namespace,
                             absl::string_view ast_path);

class IrTableGenPrinter : public CcPrinterBase {
 public:
  explicit IrTableGenPrinter(google::protobuf::io::ZeroCopyOutputStream *os)
      : CcPrinterBase(os) {}

  void PrintAst(const AstDef &ast, absl::string_view ir_path);

  // Example:
  //
  // def JsirWithStatementOp : Jsir_Op<
  //     "with_statement", [
  //         JsirStatementOpInterfaceTraits
  //     ]> {
  //   let arguments = (ins
  //     AnyType: $object
  //   );
  //
  //   let regions = (region
  //     AnyRegion: $body
  //   );
  // }
  void PrintNode(const AstDef &ast, const NodeDef &node, FieldKind kind);

  // Prints an argument for an op in MLIR ODS.
  //
  // Format:
  //
  // <TdType>: $<name>
  //
  // See Typd::TdType() for what the MLIR ODS type is for each Type.
  //
  // Example:
  //
  // AnyType: $object
  void PrintArgument(const AstDef &ast, const NodeDef &node,
                     const FieldDef &field);

  // Prints a region in an op in MLIR ODS.
  //
  // Format:
  //
  // AnyRegion: $<name>
  //
  // Example:
  //
  // AnyRegion: $body
  void PrintRegion(const AstDef &ast, const NodeDef &node,
                   const FieldDef &field);
};

// Prints the "<lang_name>ir_ops.generated.td" TableGen file.
//
// - ir_path: The directory for the IR code.
//
//   The following files are in that directory:
//   - "<lang_name>ir_dialect.td"
//   - "<lang_name>ir_ops.generated.td"
//   - "interfaces.td"
//
//   This is used to print the includes and header guards.
std::string PrintIrTableGen(const AstDef &ast, absl::string_view ir_path);

class AstToIrSourcePrinter : public CcPrinterBase {
 public:
  explicit AstToIrSourcePrinter(google::protobuf::io::ZeroCopyOutputStream *os)
      : CcPrinterBase(os) {}

  // Action: What to do with the converted IR value/attribute.
  //
  // - Def: Define a variable.
  // - Assign: Assign the value/attribute to an existing variable.
  // - Create: Just create the value/attribute and ignore it.
  //
  // See comments for Print*ToIr for more details.
  enum class Action {
    kDef,
    kAssign,
    kCreate,
  };

  // Whether a C++ expression refers to a "reference" or a "value".
  //
  // Consider the following AST node:
  // class CallExpression : ... {
  //  public:
  //   const Expression *func() const;
  //   const std::vector<std::unique_ptr<Expression>> *args() const;
  // };
  //
  // - The type of func() is "const Expression *".
  //   We consider this a "reference".
  //
  // - The type of args()[0] is "std::unique_ptr<Expression> &".
  //   We consider this a "value".
  //
  // However, in the ASTGen type system, we refer them both as
  // ClassType{"Expression"}. Therefore, we need this additional enum to make
  // the distinction.
  //
  // If a function takes a "reference" but we have a "value", we need to call
  // ".get()" to turn it into a "reference".
  enum RefOrVal {
    kRef,
    kVal,
  };

  void PrintAst(const AstDef &ast, absl::string_view cc_namespace,
                absl::string_view ast_path, absl::string_view ir_path);

  // Prints the Visit<OpName>() function.
  void PrintNonLeafNode(const AstDef &ast, const NodeDef &node, FieldKind kind);

  void PrintLeafNode(const AstDef &ast, const NodeDef &node, FieldKind kind);

  // ===========================================================================
  // Print*ToIr
  // ===========================================================================
  //
  // Prints the conversion of a C++ expression that represents a field from the
  // AST to the corresponding MLIR value/attribute. The result is later used to
  // build MLIR ops.
  // - rhs: The original C++ expression that represents a field from the AST.
  //
  // - lhs: The name of the variable to assign to or create, after the
  //        conversion.
  //
  // - action:
  //   - kDef:
  //     mlir::Value <lhs> = Convert(<rhs>);
  //   - kAssign:
  //     <lhs> = Convert(<rhs>);
  //   - kCreate:
  //     Convert(<rhs>);
  //
  // - type: The type of the AST field.
  //
  // - ref_or_val: See comments for RefOrVal.
  //
  // - kind: Kind of the field. See comments for FieldKind.
  //   If kind == FIELD_KIND_LVAL, then we need to append "Ref" to the op name.
  void PrintBuiltinToIr(const AstDef &ast, Action action,
                        const BuiltinType &type, const Symbol &lhs,
                        const std::string &rhs);

  void PrintClassToIr(const AstDef &ast, Action action, const ClassType &type,
                      FieldKind kind, const Symbol &lhs,
                      const std::string &rhs);

  void PrintClassToIr(const AstDef &ast, Action action, const ClassType &type,
                      RefOrVal ref_or_val, FieldKind kind, const Symbol &lhs,
                      const std::string &rhs);

  void PrintEnumToIr(const AstDef &ast, Action action, const EnumType &type,
                     const Symbol &lhs, const std::string &rhs);

  void PrintVariantToIr(const AstDef &ast, Action action,
                        const VariantType &type, RefOrVal ref_or_val,
                        FieldKind kind, const Symbol &lhs,
                        const std::string &rhs);

  void PrintListToIr(const AstDef &ast, Action action, const ListType &type,
                     FieldKind kind, const Symbol &lhs, const std::string &rhs);

  void PrintToIr(const AstDef &ast, Action action, const Type &type,
                 RefOrVal ref_or_val, FieldKind kind, const Symbol &lhs,
                 const std::string &rhs);

  void PrintNullableToIr(const AstDef &ast, Action action, const Type &type,
                         MaybeNull maybe_null, RefOrVal ref_or_val,
                         FieldKind kind, const Symbol &lhs,
                         const std::string &rhs);

  // Prints the code that converts an AST field to an MLIR value/attribute and
  // stores the result in a new variable.
  //
  // Format:
  //
  // <TdType> mlir_<field_name> = Visit<Type>(node-><field_name>());
  //
  // Example:
  //
  // mlir::Value mlir_object = VisitExpression(node->object());
  void PrintField(const AstDef &ast, const NodeDef &node,
                  const FieldDef &field);

  // Prints the code that converts an AST field to a region. The region has been
  // created and the code just populates blocks and ops in it.
  //
  // Format:
  //
  // mlir::Region &mlir_<field_name>_region = op.<field_name>();
  // AppendNewBlockAndPopulate(mlir_<field_name>_region, [&] {
  //   <Converts node->foo() into elements in the region.>
  // });
  //
  // Example:
  //
  // mlir::Region &mlir_body_region = op.body();
  // AppendNewBlockAndPopulate(mlir_body_region, [&] {
  //   for (const auto &element : *node->body()) {
  //     VisitStatement(element.get());
  //   }
  // });
  void PrintRegion(const AstDef &ast, const NodeDef &node,
                   const FieldDef &field);
};

// Prints the "ast_to<lang_name>ir.generated.cc" file.
//
// - cc_namespace: The namespace where all IR op classes live.
//
// - ast_path: The directory for the AST code.
//
//   "ast.generated.h" is in that directory.
//
//   This is used to print the #inclueds.
//
// - ir_path: The directory for the IR code.
//
//   The following files are in that directory:
//   - "<lang_name>ir_dialect.td"
//   - "<lang_name>ir_ops.generated.td"
//   - "interfaces.td"
//   - "conversion/ast_to_<lang_name>ir.h"
//   - "conversion/ast_to_<lang_name>ir.generated.cc"
//
//   This is used to print the #includes and header guards.
std::string PrintAstToIrSource(const AstDef &ast,
                               absl::string_view cc_namespace,
                               absl::string_view ast_path,
                               absl::string_view ir_path);

class IrToAstSourcePrinter : public CcPrinterBase {
 public:
  explicit IrToAstSourcePrinter(google::protobuf::io::ZeroCopyOutputStream *os)
      : CcPrinterBase(os) {}

  // Action: What to do with the converted AST field.
  //
  // - Def: Define a variable.
  // - Assign: Assign the value to an existing variable.
  //
  // See comments for Print*FromIr for more details.
  enum class Action {
    kDef,
    kAssign,
  };

  enum class RhsKind {
    // rhs could be:
    //  - mlir::Value
    //  - mlir::ValueRange
    //  - mlir::Block &
    //  - specific attribute.
    // Requesting type checking and error returning on type mismatch.
    kFieldGetterResult,

    // rhs could be:
    // - mlir::Operation* (for FIELD_KIND_STMT)
    // - mlir::Value (for FIELD_KIND_LVAL, FIELD_KIND_RVAL)
    // - mlir::Attribute
    // Requesting type checking and error returning on type mismatch.
    kListElement,

    // rhs is specific Op.
    // llvm::cast<Op>(op.field_name().getDefiningOp())
    kOp,
  };

  void PrintAst(const AstDef &ast, absl::string_view cc_namespace,
                absl::string_view ast_path, absl::string_view ir_path);

  // Prints the Visit<Node>() function.
  void PrintNonLeafNode(const AstDef &ast, const NodeDef &node, FieldKind kind);

  void PrintLeafNode(const AstDef &ast, const NodeDef &node, FieldKind kind);

  void PrintField(const AstDef &ast, const NodeDef &node,
                  const FieldDef &field);

  // Prints the code that, given an operation `op`:
  // (1) Fetches the region `op.getFieldName()`;
  // (2) Extracts MLIR value/operation(s) from the region, so that we get:
  //     - mlir::Value
  //     - mlir::Operation *
  //     - mlir::ValueRange
  //     - mlir::Block *
  // (4) Converts the above to a field for an AST node.
  //
  // Example output:
  // ```
  // MALDOCA_ASSIGN_OR_RETURN(auto mlir_field_name_value,
  //                          GetExprRegionValue(op.getFieldName()));
  // auto field_name_op =
  //    llvm::dyn_cast<SomeOp>(mlir_field_name_value.getDefiningOp());
  // if (field_name_op == nullptr) {
  //   return absl::InvalidArgumentError("Invalid op.");
  // }
  // MALDOCA_ASSIGN_OR_RETURN(std::unique_ptr<Some> expr,
  //                          VisitSome(field_name_op));
  // ```
  void PrintRegion(const AstDef &ast, const NodeDef &node,
                   const FieldDef &field);

  // ===========================================================================
  // Print*FromIr
  // ===========================================================================
  //
  // Prints the conversion of a C++ expression that represents MLIR
  // value/attribute to the corresponding field in the AST. The result is later
  // used to build AST nodes.
  //
  // - rhs: The original C++ expression that represents an MLIR value/attribute.
  //
  // - lhs: The name of the variable to assign to or create, after the
  //        conversion.
  //
  // - action:
  //   - kDef:
  //     <CcType> <lhs> = Convert(<rhs>);
  //   - kAssign:
  //     <lhs> = Convert(<rhs>);
  //
  // - type: The type of the AST field.
  //
  // - rhs_kind: See comments for RhsKind.
  //
  // - kind: Kind of the field. See comments for FieldKind.
  //   If kind == FIELD_KIND_LVAL, then we need to append "Ref" to the op name.
  void PrintNullableFromIr(const AstDef &ast, Action action, const Type &type,
                           MaybeNull maybe_null, FieldKind kind,
                           const Symbol &lhs, const std::string &rhs,
                           RhsKind rhs_kind);

  void PrintFromIr(const AstDef &ast, Action action, const Type &type,
                   FieldKind kind, const Symbol &lhs, const std::string &rhs,
                   RhsKind rhs_kind);

  void PrintBuiltinFromIr(const AstDef &ast, Action action,
                          const BuiltinType &type, const Symbol &lhs,
                          const std::string &rhs, RhsKind rhs_kind);

  void PrintClassFromIr(const AstDef &ast, Action action, const ClassType &type,
                        FieldKind kind, const Symbol &lhs,
                        const std::string &rhs, RhsKind rhs_kind);

  void PrintEnumFromIr(const AstDef &ast, Action action, const EnumType &type,
                       const Symbol &lhs, const std::string &rhs);

  void PrintVariantFromIr(const AstDef &ast, Action action,
                          const VariantType &type, FieldKind kind,
                          const Symbol &lhs, const std::string &rhs,
                          RhsKind rhs_kind);

  void PrintListFromIr(const AstDef &ast, Action action, const ListType &type,
                       FieldKind kind, const Symbol &lhs,
                       const std::string &rhs);

 private:
  google::protobuf::io::ZeroCopyOutputStream *os_;
};

// Prints the "<lang_name>ir_to_ast.generated.cc" file.
//
// - cc_namespace: The namespace where all IR op classes live.
//
// - ast_path: The directory for the AST code.
//
//   "ast.generated.h" is in that directory.
//
//   This is used to print the #includes.
//
// - ir_path: The directory for the IR code.
//
//   The following files are in that directory:
//   - "<lang_name>ir_dialect.td"
//   - "<lang_name>ir_ops.generated.td"
//   - "interfaces.td"
//   - "conversion/<lang_name>ir_to_ast.h"
//   - "conversion/<lang_name>ir_to_ast.generated.cc"
//
//   This is used to print the #includes and header guards.
std::string PrintIrToAstSource(const AstDef &ast,
                               absl::string_view cc_namespace,
                               absl::string_view ast_path,
                               absl::string_view ir_path);

}  // namespace maldoca

#endif  // MALDOCA_ASTGEN_AST_GEN_H_
