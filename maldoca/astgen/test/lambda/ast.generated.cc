// Copyright 2024 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// =============================================================================
// STOP!! DO NOT MODIFY!! THIS FILE IS AUTOMATICALLY GENERATED.
// =============================================================================

#include "maldoca/astgen/test/lambda/ast.generated.h"

// IWYU pragma: begin_keep
// NOLINTBEGIN(whitespace/line_length)
// clang-format off

#include <cstdint>
#include <memory>
#include <optional>
#include <string>
#include <utility>
#include <variant>
#include <vector>

#include "absl/container/flat_hash_map.h"
#include "absl/memory/memory.h"
#include "absl/log/log.h"
#include "absl/status/status.h"
#include "absl/status/statusor.h"
#include "absl/strings/str_cat.h"
#include "absl/strings/string_view.h"
#include "nlohmann/json.hpp"
#include "maldoca/base/status_macros.h"

namespace maldoca {

// =============================================================================
// LaExpression
// =============================================================================

absl::string_view LaExpressionTypeToString(LaExpressionType expression_type) {
  switch (expression_type) {
    case LaExpressionType::kVariable:
      return "Variable";
    case LaExpressionType::kFunctionDefinition:
      return "FunctionDefinition";
    case LaExpressionType::kFunctionCall:
      return "FunctionCall";
  }
}

absl::StatusOr<LaExpressionType> StringToLaExpressionType(absl::string_view s) {
  static const auto *kMap = new absl::flat_hash_map<absl::string_view, LaExpressionType> {
      {"Variable", LaExpressionType::kVariable},
      {"FunctionDefinition", LaExpressionType::kFunctionDefinition},
      {"FunctionCall", LaExpressionType::kFunctionCall},
  };

  auto it = kMap->find(s);
  if (it == kMap->end()) {
    return absl::InvalidArgumentError(absl::StrCat("Invalid string for LaExpressionType: ", s));
  }
  return it->second;
}

// =============================================================================
// LaVariable
// =============================================================================

LaVariable::LaVariable(
    std::string identifier)
    : LaExpression(),
      identifier_(std::move(identifier)) {}

absl::string_view LaVariable::identifier() const {
  return identifier_;
}

void LaVariable::set_identifier(std::string identifier) {
  identifier_ = std::move(identifier);
}

// =============================================================================
// LaFunctionDefinition
// =============================================================================

LaFunctionDefinition::LaFunctionDefinition(
    std::unique_ptr<LaVariable> parameter,
    std::unique_ptr<LaExpression> body)
    : LaExpression(),
      parameter_(std::move(parameter)),
      body_(std::move(body)) {}

LaVariable* LaFunctionDefinition::parameter() {
  return parameter_.get();
}

const LaVariable* LaFunctionDefinition::parameter() const {
  return parameter_.get();
}

void LaFunctionDefinition::set_parameter(std::unique_ptr<LaVariable> parameter) {
  parameter_ = std::move(parameter);
}

LaExpression* LaFunctionDefinition::body() {
  return body_.get();
}

const LaExpression* LaFunctionDefinition::body() const {
  return body_.get();
}

void LaFunctionDefinition::set_body(std::unique_ptr<LaExpression> body) {
  body_ = std::move(body);
}

// =============================================================================
// LaFunctionCall
// =============================================================================

LaFunctionCall::LaFunctionCall(
    std::unique_ptr<LaExpression> function,
    std::unique_ptr<LaExpression> argument)
    : LaExpression(),
      function_(std::move(function)),
      argument_(std::move(argument)) {}

LaExpression* LaFunctionCall::function() {
  return function_.get();
}

const LaExpression* LaFunctionCall::function() const {
  return function_.get();
}

void LaFunctionCall::set_function(std::unique_ptr<LaExpression> function) {
  function_ = std::move(function);
}

LaExpression* LaFunctionCall::argument() {
  return argument_.get();
}

const LaExpression* LaFunctionCall::argument() const {
  return argument_.get();
}

void LaFunctionCall::set_argument(std::unique_ptr<LaExpression> argument) {
  argument_ = std::move(argument);
}

// clang-format on
// NOLINTEND(whitespace/line_length)
// IWYU pragma: end_keep

}  // namespace maldoca
