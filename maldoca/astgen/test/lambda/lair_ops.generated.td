// Copyright 2024 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// =============================================================================
// STOP!! DO NOT MODIFY!! THIS FILE IS AUTOMATICALLY GENERATED.
// =============================================================================

#ifndef MALDOCA_ASTGEN_TEST_LAMBDA_LAIR_OPS_GENERATED_TD_
#define MALDOCA_ASTGEN_TEST_LAMBDA_LAIR_OPS_GENERATED_TD_

include "mlir/Interfaces/ControlFlowInterfaces.td"
include "mlir/Interfaces/InferTypeOpInterface.td"
include "mlir/Interfaces/LoopLikeInterface.td"
include "mlir/Interfaces/SideEffectInterfaces.td"
include "mlir/IR/OpBase.td"
include "mlir/IR/SymbolInterfaces.td"
include "maldoca/astgen/test/lambda/interfaces.td"
include "maldoca/astgen/test/lambda/lair_dialect.td"
include "maldoca/astgen/test/lambda/lair_types.td"

// lair.*_region_end: An artificial op at the end of a region to collect
// expression-related values.
//
// Take lair.exprs_region_end as example:
// ======================================
//
// Consider the following function declaration:
// ```
// function foo(arg1, arg2 = defaultValue) {
//   ...
// }
// ```
//
// We lower it to the following IR (simplified):
// ```
// %0 = lair.identifier_ref {"foo"}
// lair.function_declaration(%0) (
//   // params
//   {
//     %1 = lair.identifier_ref {"a"}
//     %2 = lair.identifier_ref {"b"}
//     %3 = lair.identifier {"defaultValue"}
//     %4 = lair.assignment_pattern_ref(%2, %3)
//     lair.exprs_region_end(%1, %4)
//   },
//   // body
//   {
//     ...
//   }
// )
// ```
//
// We can see that:
//
// 1. We put the parameter-related ops in a region, instead of taking them as
//    normal arguments. In other words, we don't do this:
//
//    ```
//    %0 = lair.identifier_ref {"foo"}
//    %1 = lair.identifier_ref {"a"}
//    %2 = lair.identifier_ref {"b"}
//    %3 = lair.identifier {"defaultValue"}
//    %4 = lair.assignment_pattern_ref(%2, %3)
//    lair.function_declaration(%0, [%1, %4]) (
//      // body
//      {
//        ...
//      }
//    )
//    ```
//
//    The reason is that sometimes an argument might have a default value, and
//    the evaluation of that default value happens once for each function call
//    (i.e. it happens "within" the function). If we take the parameter as
//    normal argument, then %3 is only evaluated once - at function definition
//    time.
//
// 2. Even though the function has two parameters, we use 4 ops to represent
//    them. This is because some parameters are more complex and require more
//    than one op.
//
// 3. We use "lair.exprs_region_end" to list the "top-level" ops for the
//    parameters. In the example above, ops [%2, %3, %4] all represent the
//    parameter "b = defaultValue", but %4 is the top-level one. In other words,
//    %4 is the root of the tree [%2, %3, %4].
//
// 4. Strictly speaking, we don't really need "lair.exprs_region_end". The ops
//    within the "params" region form several trees, and we can figure out what
//    the roots are (a root is an op whose return value is not used by any other
//    op). So the use of "lair.exprs_region_end" is mostly for convenience.
def LairExprRegionEndOp : Lair_Op<"expr_region_end", [Terminator]> {
  let arguments = (ins
    AnyType: $argument
  );
}

def LairVariableOp : Lair_Op<
    "variable", [
        LairExpressionOpInterfaceTraits
    ]> {
  let arguments = (ins
    StrAttr: $identifier
  );

  let results = (outs
    LairAnyType
  );
}

def LairVariableRefOp : Lair_Op<"variable_ref", []> {
  let arguments = (ins
    StrAttr: $identifier
  );

  let results = (outs
    LairAnyType
  );
}

def LairFunctionDefinitionOp : Lair_Op<
    "function_definition", [
        LairExpressionOpInterfaceTraits,
        NoTerminator
    ]> {
  let regions = (region
    ExprRegion: $parameter,
    ExprRegion: $body
  );

  let results = (outs
    LairAnyType
  );
}

def LairFunctionCallOp : Lair_Op<
    "function_call", [
        LairExpressionOpInterfaceTraits
    ]> {
  let arguments = (ins
    AnyType: $function,
    AnyType: $argument
  );

  let results = (outs
    LairAnyType
  );
}

#endif  // MALDOCA_ASTGEN_TEST_LAMBDA_LAIR_OPS_GENERATED_TD_
