// Copyright 2024 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// =============================================================================
// STOP!! DO NOT MODIFY!! THIS FILE IS AUTOMATICALLY GENERATED.
// =============================================================================

// NOLINTBEGIN(whitespace/line_length)
// clang-format off
// IWYU pragma: begin_keep

#include <cstdint>
#include <memory>
#include <optional>
#include <string>
#include <utility>
#include <variant>
#include <vector>

#include "maldoca/astgen/test/lambda/ast.generated.h"
#include "absl/container/flat_hash_set.h"
#include "absl/memory/memory.h"
#include "absl/status/status.h"
#include "absl/status/statusor.h"
#include "absl/strings/str_cat.h"
#include "absl/strings/string_view.h"
#include "maldoca/base/status_macros.h"
#include "nlohmann/json.hpp"

namespace maldoca {

static absl::StatusOr<std::string> GetType(const nlohmann::json& json) {
  auto type_it = json.find("type");
  if (type_it == json.end()) {
    return absl::InvalidArgumentError("`type` is undefined.");
  }
  const nlohmann::json& json_type = type_it.value();
  if (json_type.is_null()) {
    return absl::InvalidArgumentError("json_type is null.");
  }
  if (!json_type.is_string()) {
    return absl::InvalidArgumentError("`json_type` expected to be string.");
  }
  return json_type.get<std::string>();
}

// =============================================================================
// LaExpression
// =============================================================================

absl::StatusOr<std::unique_ptr<LaExpression>>
LaExpression::FromJson(const nlohmann::json& json) {
  if (!json.is_object()) {
    return absl::InvalidArgumentError("JSON is not an object.");
  }

  MALDOCA_ASSIGN_OR_RETURN(std::string type, GetType(json));

  if (type == "Variable") {
    return LaVariable::FromJson(json);
  } else if (type == "FunctionDefinition") {
    return LaFunctionDefinition::FromJson(json);
  } else if (type == "FunctionCall") {
    return LaFunctionCall::FromJson(json);
  }
  return absl::InvalidArgumentError(absl::StrCat("Invalid type: ", type));
}

// =============================================================================
// LaVariable
// =============================================================================

absl::StatusOr<std::string>
LaVariable::GetIdentifier(const nlohmann::json& json) {
  auto identifier_it = json.find("identifier");
  if (identifier_it == json.end()) {
    return absl::InvalidArgumentError("`identifier` is undefined.");
  }
  const nlohmann::json& json_identifier = identifier_it.value();

  if (json_identifier.is_null()) {
    return absl::InvalidArgumentError("json_identifier is null.");
  }
  if (!json_identifier.is_string()) {
    return absl::InvalidArgumentError("Expecting json_identifier.is_string().");
  }
  return json_identifier.get<std::string>();
}

absl::StatusOr<std::unique_ptr<LaVariable>>
LaVariable::FromJson(const nlohmann::json& json) {
  if (!json.is_object()) {
    return absl::InvalidArgumentError("JSON is not an object.");
  }

  MALDOCA_ASSIGN_OR_RETURN(auto identifier, LaVariable::GetIdentifier(json));

  return absl::make_unique<LaVariable>(
      std::move(identifier));
}

// =============================================================================
// LaFunctionDefinition
// =============================================================================

absl::StatusOr<std::unique_ptr<LaVariable>>
LaFunctionDefinition::GetParameter(const nlohmann::json& json) {
  auto parameter_it = json.find("parameter");
  if (parameter_it == json.end()) {
    return absl::InvalidArgumentError("`parameter` is undefined.");
  }
  const nlohmann::json& json_parameter = parameter_it.value();

  if (json_parameter.is_null()) {
    return absl::InvalidArgumentError("json_parameter is null.");
  }
  return LaVariable::FromJson(json_parameter);
}

absl::StatusOr<std::unique_ptr<LaExpression>>
LaFunctionDefinition::GetBody(const nlohmann::json& json) {
  auto body_it = json.find("body");
  if (body_it == json.end()) {
    return absl::InvalidArgumentError("`body` is undefined.");
  }
  const nlohmann::json& json_body = body_it.value();

  if (json_body.is_null()) {
    return absl::InvalidArgumentError("json_body is null.");
  }
  return LaExpression::FromJson(json_body);
}

absl::StatusOr<std::unique_ptr<LaFunctionDefinition>>
LaFunctionDefinition::FromJson(const nlohmann::json& json) {
  if (!json.is_object()) {
    return absl::InvalidArgumentError("JSON is not an object.");
  }

  MALDOCA_ASSIGN_OR_RETURN(auto parameter, LaFunctionDefinition::GetParameter(json));
  MALDOCA_ASSIGN_OR_RETURN(auto body, LaFunctionDefinition::GetBody(json));

  return absl::make_unique<LaFunctionDefinition>(
      std::move(parameter),
      std::move(body));
}

// =============================================================================
// LaFunctionCall
// =============================================================================

absl::StatusOr<std::unique_ptr<LaExpression>>
LaFunctionCall::GetFunction(const nlohmann::json& json) {
  auto function_it = json.find("function");
  if (function_it == json.end()) {
    return absl::InvalidArgumentError("`function` is undefined.");
  }
  const nlohmann::json& json_function = function_it.value();

  if (json_function.is_null()) {
    return absl::InvalidArgumentError("json_function is null.");
  }
  return LaExpression::FromJson(json_function);
}

absl::StatusOr<std::unique_ptr<LaExpression>>
LaFunctionCall::GetArgument(const nlohmann::json& json) {
  auto argument_it = json.find("argument");
  if (argument_it == json.end()) {
    return absl::InvalidArgumentError("`argument` is undefined.");
  }
  const nlohmann::json& json_argument = argument_it.value();

  if (json_argument.is_null()) {
    return absl::InvalidArgumentError("json_argument is null.");
  }
  return LaExpression::FromJson(json_argument);
}

absl::StatusOr<std::unique_ptr<LaFunctionCall>>
LaFunctionCall::FromJson(const nlohmann::json& json) {
  if (!json.is_object()) {
    return absl::InvalidArgumentError("JSON is not an object.");
  }

  MALDOCA_ASSIGN_OR_RETURN(auto function, LaFunctionCall::GetFunction(json));
  MALDOCA_ASSIGN_OR_RETURN(auto argument, LaFunctionCall::GetArgument(json));

  return absl::make_unique<LaFunctionCall>(
      std::move(function),
      std::move(argument));
}

// clang-format on
// NOLINTEND(whitespace/line_length)
// IWYU pragma: end_keep

}  // namespace maldoca
