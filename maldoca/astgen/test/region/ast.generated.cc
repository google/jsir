// Copyright 2024 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// =============================================================================
// STOP!! DO NOT MODIFY!! THIS FILE IS AUTOMATICALLY GENERATED.
// =============================================================================

#include "maldoca/astgen/test/region/ast.generated.h"

// IWYU pragma: begin_keep
// NOLINTBEGIN(whitespace/line_length)
// clang-format off

#include <cstdint>
#include <memory>
#include <optional>
#include <string>
#include <utility>
#include <variant>
#include <vector>

#include "absl/container/flat_hash_map.h"
#include "absl/memory/memory.h"
#include "absl/log/log.h"
#include "absl/status/status.h"
#include "absl/status/statusor.h"
#include "absl/strings/str_cat.h"
#include "absl/strings/string_view.h"
#include "nlohmann/json.hpp"
#include "maldoca/base/status_macros.h"

namespace maldoca {

// =============================================================================
// RExpr
// =============================================================================

// =============================================================================
// RStmt
// =============================================================================

RStmt::RStmt(
    std::unique_ptr<RExpr> expr)
    : expr_(std::move(expr)) {}

RExpr* RStmt::expr() {
  return expr_.get();
}

const RExpr* RStmt::expr() const {
  return expr_.get();
}

void RStmt::set_expr(std::unique_ptr<RExpr> expr) {
  expr_ = std::move(expr);
}

// =============================================================================
// RNode
// =============================================================================

RNode::RNode(
    std::unique_ptr<RExpr> expr,
    std::optional<std::unique_ptr<RExpr>> optional_expr,
    std::vector<std::unique_ptr<RExpr>> exprs,
    std::unique_ptr<RStmt> stmt,
    std::optional<std::unique_ptr<RStmt>> optional_stmt,
    std::vector<std::unique_ptr<RStmt>> stmts)
    : expr_(std::move(expr)),
      optional_expr_(std::move(optional_expr)),
      exprs_(std::move(exprs)),
      stmt_(std::move(stmt)),
      optional_stmt_(std::move(optional_stmt)),
      stmts_(std::move(stmts)) {}

RExpr* RNode::expr() {
  return expr_.get();
}

const RExpr* RNode::expr() const {
  return expr_.get();
}

void RNode::set_expr(std::unique_ptr<RExpr> expr) {
  expr_ = std::move(expr);
}

std::optional<RExpr*> RNode::optional_expr() {
  if (!optional_expr_.has_value()) {
    return std::nullopt;
  } else {
    return optional_expr_.value().get();
  }
}

std::optional<const RExpr*> RNode::optional_expr() const {
  if (!optional_expr_.has_value()) {
    return std::nullopt;
  } else {
    return optional_expr_.value().get();
  }
}

void RNode::set_optional_expr(std::optional<std::unique_ptr<RExpr>> optional_expr) {
  optional_expr_ = std::move(optional_expr);
}

std::vector<std::unique_ptr<RExpr>>* RNode::exprs() {
  return &exprs_;
}

const std::vector<std::unique_ptr<RExpr>>* RNode::exprs() const {
  return &exprs_;
}

void RNode::set_exprs(std::vector<std::unique_ptr<RExpr>> exprs) {
  exprs_ = std::move(exprs);
}

RStmt* RNode::stmt() {
  return stmt_.get();
}

const RStmt* RNode::stmt() const {
  return stmt_.get();
}

void RNode::set_stmt(std::unique_ptr<RStmt> stmt) {
  stmt_ = std::move(stmt);
}

std::optional<RStmt*> RNode::optional_stmt() {
  if (!optional_stmt_.has_value()) {
    return std::nullopt;
  } else {
    return optional_stmt_.value().get();
  }
}

std::optional<const RStmt*> RNode::optional_stmt() const {
  if (!optional_stmt_.has_value()) {
    return std::nullopt;
  } else {
    return optional_stmt_.value().get();
  }
}

void RNode::set_optional_stmt(std::optional<std::unique_ptr<RStmt>> optional_stmt) {
  optional_stmt_ = std::move(optional_stmt);
}

std::vector<std::unique_ptr<RStmt>>* RNode::stmts() {
  return &stmts_;
}

const std::vector<std::unique_ptr<RStmt>>* RNode::stmts() const {
  return &stmts_;
}

void RNode::set_stmts(std::vector<std::unique_ptr<RStmt>> stmts) {
  stmts_ = std::move(stmts);
}

// clang-format on
// NOLINTEND(whitespace/line_length)
// IWYU pragma: end_keep

}  // namespace maldoca
