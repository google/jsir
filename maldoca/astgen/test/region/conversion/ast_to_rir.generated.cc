// Copyright 2024 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// =============================================================================
// STOP!! DO NOT MODIFY!! THIS FILE IS AUTOMATICALLY GENERATED.
// =============================================================================

// IWYU pragma: begin_keep
// NOLINTBEGIN(whitespace/line_length)
// clang-format off

#include "maldoca/astgen/test/region/conversion/ast_to_rir.h"

#include <memory>
#include <utility>
#include <vector>

#include "llvm/ADT/APFloat.h"
#include "mlir/IR/Attributes.h"
#include "mlir/IR/Block.h"
#include "mlir/IR/Builders.h"
#include "mlir/IR/BuiltinAttributes.h"
#include "mlir/IR/BuiltinTypes.h"
#include "mlir/IR/Operation.h"
#include "mlir/IR/Region.h"
#include "mlir/IR/Value.h"
#include "absl/cleanup/cleanup.h"
#include "absl/log/check.h"
#include "absl/log/log.h"
#include "absl/types/optional.h"
#include "absl/types/variant.h"
#include "maldoca/astgen/test/region/ast.generated.h"
#include "maldoca/astgen/test/region/ir.h"

namespace maldoca {

RirExprOp AstToRir::VisitExpr(const RExpr *node) {
  return CreateExpr<RirExprOp>(node);
}

RirStmtOp AstToRir::VisitStmt(const RStmt *node) {
  mlir::Value mlir_expr = VisitExpr(node->expr());
  return CreateStmt<RirStmtOp>(node, mlir_expr);
}

RirNodeOp AstToRir::VisitNode(const RNode *node) {
  auto op = CreateExpr<RirNodeOp>(node);
  mlir::Region &mlir_expr_region = op.getExpr();
  AppendNewBlockAndPopulate(mlir_expr_region, [&] {
    mlir::Value mlir_expr = VisitExpr(node->expr());
    CreateStmt<RirExprRegionEndOp>(node, mlir_expr);
  });
  if (node->optional_expr().has_value()) {
    mlir::Region &mlir_optional_expr_region = op.getOptionalExpr();
    AppendNewBlockAndPopulate(mlir_optional_expr_region, [&] {
      mlir::Value mlir_optional_expr = VisitExpr(node->optional_expr().value());
      CreateStmt<RirExprRegionEndOp>(node, mlir_optional_expr);
    });
  }
  mlir::Region &mlir_exprs_region = op.getExprs();
  AppendNewBlockAndPopulate(mlir_exprs_region, [&] {
    std::vector<mlir::Value> mlir_exprs;
    for (const auto &element : *node->exprs()) {
      mlir::Value mlir_element = VisitExpr(element.get());
      mlir_exprs.push_back(std::move(mlir_element));
    }
    CreateStmt<RirExprsRegionEndOp>(node, mlir_exprs);
  });
  mlir::Region &mlir_stmt_region = op.getStmt();
  AppendNewBlockAndPopulate(mlir_stmt_region, [&] {
    VisitStmt(node->stmt());
  });
  if (node->optional_stmt().has_value()) {
    mlir::Region &mlir_optional_stmt_region = op.getOptionalStmt();
    AppendNewBlockAndPopulate(mlir_optional_stmt_region, [&] {
      VisitStmt(node->optional_stmt().value());
    });
  }
  mlir::Region &mlir_stmts_region = op.getStmts();
  AppendNewBlockAndPopulate(mlir_stmts_region, [&] {
    for (const auto &element : *node->stmts()) {
      VisitStmt(element.get());
    }
  });
  return op;
}

// clang-format on
// NOLINTEND(whitespace/line_length)
// IWYU pragma: end_keep

}  // namespace maldoca
