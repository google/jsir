// Copyright 2024 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// =============================================================================
// STOP!! DO NOT MODIFY!! THIS FILE IS AUTOMATICALLY GENERATED.
// =============================================================================

// IWYU pragma: begin_keep
// NOLINTBEGIN(whitespace/line_length)
// clang-format off

#include "maldoca/astgen/test/region/conversion/rir_to_ast.h"

#include <memory>
#include <optional>
#include <string>
#include <utility>
#include <variant>
#include <vector>

#include "llvm/ADT/APFloat.h"
#include "llvm/ADT/TypeSwitch.h"
#include "llvm/Support/Casting.h"
#include "mlir/IR/Attributes.h"
#include "mlir/IR/Block.h"
#include "mlir/IR/Builders.h"
#include "mlir/IR/BuiltinAttributes.h"
#include "mlir/IR/BuiltinTypes.h"
#include "mlir/IR/Operation.h"
#include "mlir/IR/Region.h"
#include "mlir/IR/Value.h"
#include "absl/cleanup/cleanup.h"
#include "absl/log/check.h"
#include "absl/log/log.h"
#include "absl/status/status.h"
#include "absl/status/statusor.h"
#include "absl/strings/str_cat.h"
#include "absl/types/optional.h"
#include "absl/types/variant.h"
#include "maldoca/base/status_macros.h"
#include "maldoca/astgen/test/region/ast.generated.h"
#include "maldoca/astgen/test/region/ir.h"

namespace maldoca {

absl::StatusOr<std::unique_ptr<RExpr>>
RirToAst::VisitExpr(RirExprOp op) {
  return Create<RExpr>(
      op);
}

absl::StatusOr<std::unique_ptr<RStmt>>
RirToAst::VisitStmt(RirStmtOp op) {
  auto expr_op = llvm::dyn_cast<RirExprOp>(op.getExpr().getDefiningOp());
  if (expr_op == nullptr) {
    return absl::InvalidArgumentError(
        absl::StrCat("Expected RirExprOp, got ",
                     op.getExpr().getDefiningOp()->getName().getStringRef().str(), "."));
  }
  MALDOCA_ASSIGN_OR_RETURN(std::unique_ptr<RExpr> expr, VisitExpr(expr_op));
  return Create<RStmt>(
      op,
      std::move(expr));
}

absl::StatusOr<std::unique_ptr<RNode>>
RirToAst::VisitNode(RirNodeOp op) {
  MALDOCA_ASSIGN_OR_RETURN(auto mlir_expr_value, GetExprRegionValue(op.getExpr()));
  auto expr_op = llvm::dyn_cast<RirExprOp>(mlir_expr_value.getDefiningOp());
  if (expr_op == nullptr) {
    return absl::InvalidArgumentError(
        absl::StrCat("Expected RirExprOp, got ",
                     mlir_expr_value.getDefiningOp()->getName().getStringRef().str(), "."));
  }
  MALDOCA_ASSIGN_OR_RETURN(std::unique_ptr<RExpr> expr, VisitExpr(expr_op));
  std::optional<std::unique_ptr<RExpr>> optional_expr;
  if (!op.getOptionalExpr().empty()) {
    MALDOCA_ASSIGN_OR_RETURN(auto mlir_optional_expr_value, GetExprRegionValue(op.getOptionalExpr()));
    auto optional_expr_op = llvm::dyn_cast<RirExprOp>(mlir_optional_expr_value.getDefiningOp());
    if (optional_expr_op == nullptr) {
      return absl::InvalidArgumentError(
          absl::StrCat("Expected RirExprOp, got ",
                       mlir_optional_expr_value.getDefiningOp()->getName().getStringRef().str(), "."));
    }
    MALDOCA_ASSIGN_OR_RETURN(optional_expr, VisitExpr(optional_expr_op));
  }
  MALDOCA_ASSIGN_OR_RETURN(auto mlir_exprs_values, GetExprsRegionValues(op.getExprs()));
  std::vector<std::unique_ptr<RExpr>> exprs;
  for (mlir::Value mlir_exprs_element_unchecked : mlir_exprs_values) {
    auto exprs_element_op = llvm::dyn_cast<RirExprOp>(mlir_exprs_element_unchecked.getDefiningOp());
    if (exprs_element_op == nullptr) {
      return absl::InvalidArgumentError(
          absl::StrCat("Expected RirExprOp, got ",
                       mlir_exprs_element_unchecked.getDefiningOp()->getName().getStringRef().str(), "."));
    }
    MALDOCA_ASSIGN_OR_RETURN(std::unique_ptr<RExpr> exprs_element, VisitExpr(exprs_element_op));
    exprs.push_back(std::move(exprs_element));
  }
  MALDOCA_ASSIGN_OR_RETURN(auto mlir_stmt_operation, GetStmtRegionOperation(op.getStmt()));
  auto stmt_op = llvm::dyn_cast<RirStmtOp>(mlir_stmt_operation);
  if (stmt_op == nullptr) {
    return absl::InvalidArgumentError(
        absl::StrCat("Expected RirStmtOp, got ",
                     mlir_stmt_operation->getName().getStringRef().str(), "."));
  }
  MALDOCA_ASSIGN_OR_RETURN(std::unique_ptr<RStmt> stmt, VisitStmt(stmt_op));
  std::optional<std::unique_ptr<RStmt>> optional_stmt;
  if (!op.getOptionalStmt().empty()) {
    MALDOCA_ASSIGN_OR_RETURN(auto mlir_optional_stmt_operation, GetStmtRegionOperation(op.getOptionalStmt()));
    auto optional_stmt_op = llvm::dyn_cast<RirStmtOp>(mlir_optional_stmt_operation);
    if (optional_stmt_op == nullptr) {
      return absl::InvalidArgumentError(
          absl::StrCat("Expected RirStmtOp, got ",
                       mlir_optional_stmt_operation->getName().getStringRef().str(), "."));
    }
    MALDOCA_ASSIGN_OR_RETURN(optional_stmt, VisitStmt(optional_stmt_op));
  }
  MALDOCA_ASSIGN_OR_RETURN(auto mlir_stmts_block, GetStmtsRegionBlock(op.getStmts()));
  std::vector<std::unique_ptr<RStmt>> stmts;
  for (mlir::Operation& mlir_stmts_element_unchecked : *mlir_stmts_block) {
    auto stmts_element_op = llvm::dyn_cast<RirStmtOp>(mlir_stmts_element_unchecked);
    if (stmts_element_op == nullptr) {
      continue;
    }
    MALDOCA_ASSIGN_OR_RETURN(std::unique_ptr<RStmt> stmts_element, VisitStmt(stmts_element_op));
    stmts.push_back(std::move(stmts_element));
  }
  return Create<RNode>(
      op,
      std::move(expr),
      std::move(optional_expr),
      std::move(exprs),
      std::move(stmt),
      std::move(optional_stmt),
      std::move(stmts));
}

// clang-format on
// NOLINTEND(whitespace/line_length)
// IWYU pragma: end_keep

}  // namespace maldoca
