// Copyright 2024 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// =============================================================================
// STOP!! DO NOT MODIFY!! THIS FILE IS AUTOMATICALLY GENERATED.
// =============================================================================

// NOLINTBEGIN(whitespace/line_length)
// clang-format off
// IWYU pragma: begin_keep

#include <cstdint>
#include <memory>
#include <optional>
#include <string>
#include <utility>
#include <variant>
#include <vector>

#include "maldoca/astgen/test/region/ast.generated.h"
#include "absl/container/flat_hash_set.h"
#include "absl/memory/memory.h"
#include "absl/status/status.h"
#include "absl/status/statusor.h"
#include "absl/strings/str_cat.h"
#include "absl/strings/string_view.h"
#include "maldoca/base/status_macros.h"
#include "nlohmann/json.hpp"

namespace maldoca {

// =============================================================================
// RExpr
// =============================================================================

absl::StatusOr<std::unique_ptr<RExpr>>
RExpr::FromJson(const nlohmann::json& json) {
  if (!json.is_object()) {
    return absl::InvalidArgumentError("JSON is not an object.");
  }


  return absl::make_unique<RExpr>(
  );
}

// =============================================================================
// RStmt
// =============================================================================

absl::StatusOr<std::unique_ptr<RExpr>>
RStmt::GetExpr(const nlohmann::json& json) {
  auto expr_it = json.find("expr");
  if (expr_it == json.end()) {
    return absl::InvalidArgumentError("`expr` is undefined.");
  }
  const nlohmann::json& json_expr = expr_it.value();

  if (json_expr.is_null()) {
    return absl::InvalidArgumentError("json_expr is null.");
  }
  return RExpr::FromJson(json_expr);
}

absl::StatusOr<std::unique_ptr<RStmt>>
RStmt::FromJson(const nlohmann::json& json) {
  if (!json.is_object()) {
    return absl::InvalidArgumentError("JSON is not an object.");
  }

  MALDOCA_ASSIGN_OR_RETURN(auto expr, RStmt::GetExpr(json));

  return absl::make_unique<RStmt>(
      std::move(expr));
}

// =============================================================================
// RNode
// =============================================================================

absl::StatusOr<std::unique_ptr<RExpr>>
RNode::GetExpr(const nlohmann::json& json) {
  auto expr_it = json.find("expr");
  if (expr_it == json.end()) {
    return absl::InvalidArgumentError("`expr` is undefined.");
  }
  const nlohmann::json& json_expr = expr_it.value();

  if (json_expr.is_null()) {
    return absl::InvalidArgumentError("json_expr is null.");
  }
  return RExpr::FromJson(json_expr);
}

absl::StatusOr<std::optional<std::unique_ptr<RExpr>>>
RNode::GetOptionalExpr(const nlohmann::json& json) {
  auto optional_expr_it = json.find("optionalExpr");
  if (optional_expr_it == json.end()) {
    return absl::InvalidArgumentError("`optionalExpr` is undefined.");
  }
  const nlohmann::json& json_optional_expr = optional_expr_it.value();

  if (json_optional_expr.is_null()) {
    return std::nullopt;
  }
  return RExpr::FromJson(json_optional_expr);
}

absl::StatusOr<std::vector<std::unique_ptr<RExpr>>>
RNode::GetExprs(const nlohmann::json& json) {
  auto exprs_it = json.find("exprs");
  if (exprs_it == json.end()) {
    return absl::InvalidArgumentError("`exprs` is undefined.");
  }
  const nlohmann::json& json_exprs = exprs_it.value();

  if (json_exprs.is_null()) {
    return absl::InvalidArgumentError("json_exprs is null.");
  }
  if (!json_exprs.is_array()) {
    return absl::InvalidArgumentError("json_exprs expected to be array.");
  }

  std::vector<std::unique_ptr<RExpr>> exprs;
  for (const nlohmann::json& json_exprs_element : json_exprs) {
    if (json_exprs_element.is_null()) {
      return absl::InvalidArgumentError("json_exprs_element is null.");
    }
    MALDOCA_ASSIGN_OR_RETURN(auto exprs_element, RExpr::FromJson(json_exprs_element));
    exprs.push_back(std::move(exprs_element));
  }
  return exprs;
}

absl::StatusOr<std::unique_ptr<RStmt>>
RNode::GetStmt(const nlohmann::json& json) {
  auto stmt_it = json.find("stmt");
  if (stmt_it == json.end()) {
    return absl::InvalidArgumentError("`stmt` is undefined.");
  }
  const nlohmann::json& json_stmt = stmt_it.value();

  if (json_stmt.is_null()) {
    return absl::InvalidArgumentError("json_stmt is null.");
  }
  return RStmt::FromJson(json_stmt);
}

absl::StatusOr<std::optional<std::unique_ptr<RStmt>>>
RNode::GetOptionalStmt(const nlohmann::json& json) {
  auto optional_stmt_it = json.find("optionalStmt");
  if (optional_stmt_it == json.end()) {
    return absl::InvalidArgumentError("`optionalStmt` is undefined.");
  }
  const nlohmann::json& json_optional_stmt = optional_stmt_it.value();

  if (json_optional_stmt.is_null()) {
    return std::nullopt;
  }
  return RStmt::FromJson(json_optional_stmt);
}

absl::StatusOr<std::vector<std::unique_ptr<RStmt>>>
RNode::GetStmts(const nlohmann::json& json) {
  auto stmts_it = json.find("stmts");
  if (stmts_it == json.end()) {
    return absl::InvalidArgumentError("`stmts` is undefined.");
  }
  const nlohmann::json& json_stmts = stmts_it.value();

  if (json_stmts.is_null()) {
    return absl::InvalidArgumentError("json_stmts is null.");
  }
  if (!json_stmts.is_array()) {
    return absl::InvalidArgumentError("json_stmts expected to be array.");
  }

  std::vector<std::unique_ptr<RStmt>> stmts;
  for (const nlohmann::json& json_stmts_element : json_stmts) {
    if (json_stmts_element.is_null()) {
      return absl::InvalidArgumentError("json_stmts_element is null.");
    }
    MALDOCA_ASSIGN_OR_RETURN(auto stmts_element, RStmt::FromJson(json_stmts_element));
    stmts.push_back(std::move(stmts_element));
  }
  return stmts;
}

absl::StatusOr<std::unique_ptr<RNode>>
RNode::FromJson(const nlohmann::json& json) {
  if (!json.is_object()) {
    return absl::InvalidArgumentError("JSON is not an object.");
  }

  MALDOCA_ASSIGN_OR_RETURN(auto expr, RNode::GetExpr(json));
  MALDOCA_ASSIGN_OR_RETURN(auto optional_expr, RNode::GetOptionalExpr(json));
  MALDOCA_ASSIGN_OR_RETURN(auto exprs, RNode::GetExprs(json));
  MALDOCA_ASSIGN_OR_RETURN(auto stmt, RNode::GetStmt(json));
  MALDOCA_ASSIGN_OR_RETURN(auto optional_stmt, RNode::GetOptionalStmt(json));
  MALDOCA_ASSIGN_OR_RETURN(auto stmts, RNode::GetStmts(json));

  return absl::make_unique<RNode>(
      std::move(expr),
      std::move(optional_expr),
      std::move(exprs),
      std::move(stmt),
      std::move(optional_stmt),
      std::move(stmts));
}

// clang-format on
// NOLINTEND(whitespace/line_length)
// IWYU pragma: end_keep

}  // namespace maldoca
