// Copyright 2024 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// =============================================================================
// STOP!! DO NOT MODIFY!! THIS FILE IS AUTOMATICALLY GENERATED.
// =============================================================================

#include "maldoca/astgen/test/union/ast.generated.h"

// IWYU pragma: begin_keep
// NOLINTBEGIN(whitespace/line_length)
// clang-format off

#include <cstdint>
#include <memory>
#include <optional>
#include <string>
#include <utility>
#include <variant>
#include <vector>

#include "absl/container/flat_hash_map.h"
#include "absl/memory/memory.h"
#include "absl/log/log.h"
#include "absl/status/status.h"
#include "absl/status/statusor.h"
#include "absl/strings/str_cat.h"
#include "absl/strings/string_view.h"
#include "nlohmann/json.hpp"
#include "maldoca/base/status_macros.h"

namespace maldoca {

// =============================================================================
// EUnionType
// =============================================================================

absl::string_view EUnionTypeTypeToString(EUnionTypeType union_type_type) {
  switch (union_type_type) {
    case EUnionTypeType::kSubNodeA:
      return "SubNodeA";
    case EUnionTypeType::kSubNodeB:
      return "SubNodeB";
  }
}

absl::StatusOr<EUnionTypeType> StringToEUnionTypeType(absl::string_view s) {
  static const auto *kMap = new absl::flat_hash_map<absl::string_view, EUnionTypeType> {
      {"SubNodeA", EUnionTypeType::kSubNodeA},
      {"SubNodeB", EUnionTypeType::kSubNodeB},
  };

  auto it = kMap->find(s);
  if (it == kMap->end()) {
    return absl::InvalidArgumentError(absl::StrCat("Invalid string for EUnionTypeType: ", s));
  }
  return it->second;
}

// =============================================================================
// ENode
// =============================================================================

ENode::ENode(
    std::string name,
    std::unique_ptr<EUnionType> content)
    : name_(std::move(name)),
      content_(std::move(content)) {}

absl::string_view ENode::name() const {
  return name_;
}

void ENode::set_name(std::string name) {
  name_ = std::move(name);
}

EUnionType* ENode::content() {
  return content_.get();
}

const EUnionType* ENode::content() const {
  return content_.get();
}

void ENode::set_content(std::unique_ptr<EUnionType> content) {
  content_ = std::move(content);
}

// =============================================================================
// ESubNodeA
// =============================================================================

ESubNodeA::ESubNodeA(
    std::string value_a)
    : EUnionType(),
      value_a_(std::move(value_a)) {}

absl::string_view ESubNodeA::value_a() const {
  return value_a_;
}

void ESubNodeA::set_value_a(std::string value_a) {
  value_a_ = std::move(value_a);
}

// =============================================================================
// ESubNodeB
// =============================================================================

ESubNodeB::ESubNodeB(
    std::string value_b)
    : EUnionType(),
      value_b_(std::move(value_b)) {}

absl::string_view ESubNodeB::value_b() const {
  return value_b_;
}

void ESubNodeB::set_value_b(std::string value_b) {
  value_b_ = std::move(value_b);
}

// clang-format on
// NOLINTEND(whitespace/line_length)
// IWYU pragma: end_keep

}  // namespace maldoca
