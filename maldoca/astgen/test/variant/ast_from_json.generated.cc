// Copyright 2024 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// =============================================================================
// STOP!! DO NOT MODIFY!! THIS FILE IS AUTOMATICALLY GENERATED.
// =============================================================================

// NOLINTBEGIN(whitespace/line_length)
// clang-format off
// IWYU pragma: begin_keep

#include <cstdint>
#include <memory>
#include <optional>
#include <string>
#include <utility>
#include <variant>
#include <vector>

#include "maldoca/astgen/test/variant/ast.generated.h"
#include "absl/container/flat_hash_set.h"
#include "absl/memory/memory.h"
#include "absl/status/status.h"
#include "absl/status/statusor.h"
#include "absl/strings/str_cat.h"
#include "absl/strings/string_view.h"
#include "maldoca/base/status_macros.h"
#include "nlohmann/json.hpp"

namespace maldoca {

static absl::StatusOr<std::string> GetType(const nlohmann::json& json) {
  auto type_it = json.find("type");
  if (type_it == json.end()) {
    return absl::InvalidArgumentError("`type` is undefined.");
  }
  const nlohmann::json& json_type = type_it.value();
  if (json_type.is_null()) {
    return absl::InvalidArgumentError("json_type is null.");
  }
  if (!json_type.is_string()) {
    return absl::InvalidArgumentError("`json_type` expected to be string.");
  }
  return json_type.get<std::string>();
}

// =============================================================================
// VBaseClass
// =============================================================================

absl::StatusOr<std::unique_ptr<VBaseClass>>
VBaseClass::FromJson(const nlohmann::json& json) {
  if (!json.is_object()) {
    return absl::InvalidArgumentError("JSON is not an object.");
  }

  MALDOCA_ASSIGN_OR_RETURN(std::string type, GetType(json));

  if (type == "DerivedClass1") {
    return VDerivedClass1::FromJson(json);
  } else if (type == "DerivedClass2") {
    return VDerivedClass2::FromJson(json);
  }
  return absl::InvalidArgumentError(absl::StrCat("Invalid type: ", type));
}

// =============================================================================
// VDerivedClass1
// =============================================================================

static bool IsDerivedClass1(const nlohmann::json& json) {
  if (!json.is_object()) {
    return false;
  }
  auto type_it = json.find("type");
  if (type_it == json.end()) {
    return false;
  }
  const nlohmann::json &type_json = type_it.value();
  if (!type_json.is_string()) {
    return false;
  }
  const std::string &type = type_json.get<std::string>();
  return type == "DerivedClass1";
}

absl::StatusOr<std::unique_ptr<VDerivedClass1>>
VDerivedClass1::FromJson(const nlohmann::json& json) {
  if (!json.is_object()) {
    return absl::InvalidArgumentError("JSON is not an object.");
  }


  return absl::make_unique<VDerivedClass1>(
  );
}

// =============================================================================
// VDerivedClass2
// =============================================================================

static bool IsDerivedClass2(const nlohmann::json& json) {
  if (!json.is_object()) {
    return false;
  }
  auto type_it = json.find("type");
  if (type_it == json.end()) {
    return false;
  }
  const nlohmann::json &type_json = type_it.value();
  if (!type_json.is_string()) {
    return false;
  }
  const std::string &type = type_json.get<std::string>();
  return type == "DerivedClass2";
}

absl::StatusOr<std::unique_ptr<VDerivedClass2>>
VDerivedClass2::FromJson(const nlohmann::json& json) {
  if (!json.is_object()) {
    return absl::InvalidArgumentError("JSON is not an object.");
  }


  return absl::make_unique<VDerivedClass2>(
  );
}

// =============================================================================
// VNode
// =============================================================================

absl::StatusOr<std::variant<double, std::string>>
VNode::GetSimpleVariantBuiltin(const nlohmann::json& json) {
  auto simple_variant_builtin_it = json.find("simpleVariantBuiltin");
  if (simple_variant_builtin_it == json.end()) {
    return absl::InvalidArgumentError("`simpleVariantBuiltin` is undefined.");
  }
  const nlohmann::json& json_simple_variant_builtin = simple_variant_builtin_it.value();

  if (json_simple_variant_builtin.is_null()) {
    return absl::InvalidArgumentError("json_simple_variant_builtin is null.");
  }
  if (json_simple_variant_builtin.is_number()) {
    return json_simple_variant_builtin.get<double>();
  } else if (json_simple_variant_builtin.is_string()) {
    return json_simple_variant_builtin.get<std::string>();
  } else {
    auto result = absl::InvalidArgumentError("json_simple_variant_builtin has invalid type.");
    result.SetPayload("json", absl::Cord{json.dump()});
    result.SetPayload("json_element", absl::Cord{json_simple_variant_builtin.dump()});
    return result;
  }
}

absl::StatusOr<std::optional<std::variant<double, std::string>>>
VNode::GetNullableVariantBuiltin(const nlohmann::json& json) {
  auto nullable_variant_builtin_it = json.find("nullableVariantBuiltin");
  if (nullable_variant_builtin_it == json.end()) {
    return absl::InvalidArgumentError("`nullableVariantBuiltin` is undefined.");
  }
  const nlohmann::json& json_nullable_variant_builtin = nullable_variant_builtin_it.value();

  if (json_nullable_variant_builtin.is_null()) {
    return std::nullopt;
  }
  if (json_nullable_variant_builtin.is_number()) {
    return json_nullable_variant_builtin.get<double>();
  } else if (json_nullable_variant_builtin.is_string()) {
    return json_nullable_variant_builtin.get<std::string>();
  } else {
    auto result = absl::InvalidArgumentError("json_nullable_variant_builtin has invalid type.");
    result.SetPayload("json", absl::Cord{json.dump()});
    result.SetPayload("json_element", absl::Cord{json_nullable_variant_builtin.dump()});
    return result;
  }
}

absl::StatusOr<std::optional<std::variant<double, std::string>>>
VNode::GetOptionalVariantBuiltin(const nlohmann::json& json) {
  auto optional_variant_builtin_it = json.find("optionalVariantBuiltin");
  if (optional_variant_builtin_it == json.end()) {
    return std::nullopt;
  }
  const nlohmann::json& json_optional_variant_builtin = optional_variant_builtin_it.value();

  if (json_optional_variant_builtin.is_null()) {
    return absl::InvalidArgumentError("json_optional_variant_builtin is null.");
  }
  if (json_optional_variant_builtin.is_number()) {
    return json_optional_variant_builtin.get<double>();
  } else if (json_optional_variant_builtin.is_string()) {
    return json_optional_variant_builtin.get<std::string>();
  } else {
    auto result = absl::InvalidArgumentError("json_optional_variant_builtin has invalid type.");
    result.SetPayload("json", absl::Cord{json.dump()});
    result.SetPayload("json_element", absl::Cord{json_optional_variant_builtin.dump()});
    return result;
  }
}

absl::StatusOr<std::variant<std::unique_ptr<VDerivedClass1>, std::unique_ptr<VDerivedClass2>>>
VNode::GetSimpleVariantClass(const nlohmann::json& json) {
  auto simple_variant_class_it = json.find("simpleVariantClass");
  if (simple_variant_class_it == json.end()) {
    return absl::InvalidArgumentError("`simpleVariantClass` is undefined.");
  }
  const nlohmann::json& json_simple_variant_class = simple_variant_class_it.value();

  if (json_simple_variant_class.is_null()) {
    return absl::InvalidArgumentError("json_simple_variant_class is null.");
  }
  if (IsDerivedClass1(json_simple_variant_class)) {
    return VDerivedClass1::FromJson(json_simple_variant_class);
  } else if (IsDerivedClass2(json_simple_variant_class)) {
    return VDerivedClass2::FromJson(json_simple_variant_class);
  } else {
    auto result = absl::InvalidArgumentError("json_simple_variant_class has invalid type.");
    result.SetPayload("json", absl::Cord{json.dump()});
    result.SetPayload("json_element", absl::Cord{json_simple_variant_class.dump()});
    return result;
  }
}

absl::StatusOr<std::optional<std::variant<std::unique_ptr<VDerivedClass1>, std::unique_ptr<VDerivedClass2>>>>
VNode::GetNullableVariantClass(const nlohmann::json& json) {
  auto nullable_variant_class_it = json.find("nullableVariantClass");
  if (nullable_variant_class_it == json.end()) {
    return absl::InvalidArgumentError("`nullableVariantClass` is undefined.");
  }
  const nlohmann::json& json_nullable_variant_class = nullable_variant_class_it.value();

  if (json_nullable_variant_class.is_null()) {
    return std::nullopt;
  }
  if (IsDerivedClass1(json_nullable_variant_class)) {
    return VDerivedClass1::FromJson(json_nullable_variant_class);
  } else if (IsDerivedClass2(json_nullable_variant_class)) {
    return VDerivedClass2::FromJson(json_nullable_variant_class);
  } else {
    auto result = absl::InvalidArgumentError("json_nullable_variant_class has invalid type.");
    result.SetPayload("json", absl::Cord{json.dump()});
    result.SetPayload("json_element", absl::Cord{json_nullable_variant_class.dump()});
    return result;
  }
}

absl::StatusOr<std::optional<std::variant<std::unique_ptr<VDerivedClass1>, std::unique_ptr<VDerivedClass2>>>>
VNode::GetOptionalVariantClass(const nlohmann::json& json) {
  auto optional_variant_class_it = json.find("optionalVariantClass");
  if (optional_variant_class_it == json.end()) {
    return std::nullopt;
  }
  const nlohmann::json& json_optional_variant_class = optional_variant_class_it.value();

  if (json_optional_variant_class.is_null()) {
    return absl::InvalidArgumentError("json_optional_variant_class is null.");
  }
  if (IsDerivedClass1(json_optional_variant_class)) {
    return VDerivedClass1::FromJson(json_optional_variant_class);
  } else if (IsDerivedClass2(json_optional_variant_class)) {
    return VDerivedClass2::FromJson(json_optional_variant_class);
  } else {
    auto result = absl::InvalidArgumentError("json_optional_variant_class has invalid type.");
    result.SetPayload("json", absl::Cord{json.dump()});
    result.SetPayload("json_element", absl::Cord{json_optional_variant_class.dump()});
    return result;
  }
}

absl::StatusOr<std::unique_ptr<VNode>>
VNode::FromJson(const nlohmann::json& json) {
  if (!json.is_object()) {
    return absl::InvalidArgumentError("JSON is not an object.");
  }

  MALDOCA_ASSIGN_OR_RETURN(auto simple_variant_builtin, VNode::GetSimpleVariantBuiltin(json));
  MALDOCA_ASSIGN_OR_RETURN(auto nullable_variant_builtin, VNode::GetNullableVariantBuiltin(json));
  MALDOCA_ASSIGN_OR_RETURN(auto optional_variant_builtin, VNode::GetOptionalVariantBuiltin(json));
  MALDOCA_ASSIGN_OR_RETURN(auto simple_variant_class, VNode::GetSimpleVariantClass(json));
  MALDOCA_ASSIGN_OR_RETURN(auto nullable_variant_class, VNode::GetNullableVariantClass(json));
  MALDOCA_ASSIGN_OR_RETURN(auto optional_variant_class, VNode::GetOptionalVariantClass(json));

  return absl::make_unique<VNode>(
      std::move(simple_variant_builtin),
      std::move(nullable_variant_builtin),
      std::move(optional_variant_builtin),
      std::move(simple_variant_class),
      std::move(nullable_variant_class),
      std::move(optional_variant_class));
}

// clang-format on
// NOLINTEND(whitespace/line_length)
// IWYU pragma: end_keep

}  // namespace maldoca
