// Copyright 2024 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// =============================================================================
// STOP!! DO NOT MODIFY!! THIS FILE IS AUTOMATICALLY GENERATED.
// =============================================================================

#include "maldoca/astgen/test/variant/ast.generated.h"

// IWYU pragma: begin_keep
// NOLINTBEGIN(whitespace/line_length)
// clang-format off

#include <cstdint>
#include <memory>
#include <optional>
#include <string>
#include <utility>
#include <variant>
#include <vector>

#include "absl/container/flat_hash_map.h"
#include "absl/memory/memory.h"
#include "absl/log/log.h"
#include "absl/status/status.h"
#include "absl/status/statusor.h"
#include "absl/strings/str_cat.h"
#include "absl/strings/string_view.h"
#include "nlohmann/json.hpp"
#include "maldoca/base/status_macros.h"

namespace maldoca {

// =============================================================================
// VBaseClass
// =============================================================================

absl::string_view VBaseClassTypeToString(VBaseClassType base_class_type) {
  switch (base_class_type) {
    case VBaseClassType::kDerivedClass1:
      return "DerivedClass1";
    case VBaseClassType::kDerivedClass2:
      return "DerivedClass2";
  }
}

absl::StatusOr<VBaseClassType> StringToVBaseClassType(absl::string_view s) {
  static const auto *kMap = new absl::flat_hash_map<absl::string_view, VBaseClassType> {
      {"DerivedClass1", VBaseClassType::kDerivedClass1},
      {"DerivedClass2", VBaseClassType::kDerivedClass2},
  };

  auto it = kMap->find(s);
  if (it == kMap->end()) {
    return absl::InvalidArgumentError(absl::StrCat("Invalid string for VBaseClassType: ", s));
  }
  return it->second;
}

// =============================================================================
// VDerivedClass1
// =============================================================================

// =============================================================================
// VDerivedClass2
// =============================================================================

// =============================================================================
// VNode
// =============================================================================

VNode::VNode(
    std::variant<double, std::string> simple_variant_builtin,
    std::optional<std::variant<double, std::string>> nullable_variant_builtin,
    std::optional<std::variant<double, std::string>> optional_variant_builtin,
    std::variant<std::unique_ptr<VDerivedClass1>, std::unique_ptr<VDerivedClass2>> simple_variant_class,
    std::optional<std::variant<std::unique_ptr<VDerivedClass1>, std::unique_ptr<VDerivedClass2>>> nullable_variant_class,
    std::optional<std::variant<std::unique_ptr<VDerivedClass1>, std::unique_ptr<VDerivedClass2>>> optional_variant_class)
    : simple_variant_builtin_(std::move(simple_variant_builtin)),
      nullable_variant_builtin_(std::move(nullable_variant_builtin)),
      optional_variant_builtin_(std::move(optional_variant_builtin)),
      simple_variant_class_(std::move(simple_variant_class)),
      nullable_variant_class_(std::move(nullable_variant_class)),
      optional_variant_class_(std::move(optional_variant_class)) {}

std::variant<double, absl::string_view> VNode::simple_variant_builtin() const {
  switch (simple_variant_builtin_.index()) {
    case 0: {
      return std::get<0>(simple_variant_builtin_);
    }
    case 1: {
      return std::get<1>(simple_variant_builtin_);
    }
    default:
      LOG(FATAL) << "Unreachable code.";
  }
}

void VNode::set_simple_variant_builtin(std::variant<double, std::string> simple_variant_builtin) {
  simple_variant_builtin_ = std::move(simple_variant_builtin);
}

std::optional<std::variant<double, absl::string_view>> VNode::nullable_variant_builtin() const {
  if (!nullable_variant_builtin_.has_value()) {
    return std::nullopt;
  } else {
    switch (nullable_variant_builtin_.value().index()) {
      case 0: {
        return std::get<0>(nullable_variant_builtin_.value());
      }
      case 1: {
        return std::get<1>(nullable_variant_builtin_.value());
      }
      default:
        LOG(FATAL) << "Unreachable code.";
    }
  }
}

void VNode::set_nullable_variant_builtin(std::optional<std::variant<double, std::string>> nullable_variant_builtin) {
  nullable_variant_builtin_ = std::move(nullable_variant_builtin);
}

std::optional<std::variant<double, absl::string_view>> VNode::optional_variant_builtin() const {
  if (!optional_variant_builtin_.has_value()) {
    return std::nullopt;
  } else {
    switch (optional_variant_builtin_.value().index()) {
      case 0: {
        return std::get<0>(optional_variant_builtin_.value());
      }
      case 1: {
        return std::get<1>(optional_variant_builtin_.value());
      }
      default:
        LOG(FATAL) << "Unreachable code.";
    }
  }
}

void VNode::set_optional_variant_builtin(std::optional<std::variant<double, std::string>> optional_variant_builtin) {
  optional_variant_builtin_ = std::move(optional_variant_builtin);
}

std::variant<VDerivedClass1*, VDerivedClass2*> VNode::simple_variant_class() {
  switch (simple_variant_class_.index()) {
    case 0: {
      return std::get<0>(simple_variant_class_).get();
    }
    case 1: {
      return std::get<1>(simple_variant_class_).get();
    }
    default:
      LOG(FATAL) << "Unreachable code.";
  }
}

std::variant<const VDerivedClass1*, const VDerivedClass2*> VNode::simple_variant_class() const {
  switch (simple_variant_class_.index()) {
    case 0: {
      return std::get<0>(simple_variant_class_).get();
    }
    case 1: {
      return std::get<1>(simple_variant_class_).get();
    }
    default:
      LOG(FATAL) << "Unreachable code.";
  }
}

void VNode::set_simple_variant_class(std::variant<std::unique_ptr<VDerivedClass1>, std::unique_ptr<VDerivedClass2>> simple_variant_class) {
  simple_variant_class_ = std::move(simple_variant_class);
}

std::optional<std::variant<VDerivedClass1*, VDerivedClass2*>> VNode::nullable_variant_class() {
  if (!nullable_variant_class_.has_value()) {
    return std::nullopt;
  } else {
    switch (nullable_variant_class_.value().index()) {
      case 0: {
        return std::get<0>(nullable_variant_class_.value()).get();
      }
      case 1: {
        return std::get<1>(nullable_variant_class_.value()).get();
      }
      default:
        LOG(FATAL) << "Unreachable code.";
    }
  }
}

std::optional<std::variant<const VDerivedClass1*, const VDerivedClass2*>> VNode::nullable_variant_class() const {
  if (!nullable_variant_class_.has_value()) {
    return std::nullopt;
  } else {
    switch (nullable_variant_class_.value().index()) {
      case 0: {
        return std::get<0>(nullable_variant_class_.value()).get();
      }
      case 1: {
        return std::get<1>(nullable_variant_class_.value()).get();
      }
      default:
        LOG(FATAL) << "Unreachable code.";
    }
  }
}

void VNode::set_nullable_variant_class(std::optional<std::variant<std::unique_ptr<VDerivedClass1>, std::unique_ptr<VDerivedClass2>>> nullable_variant_class) {
  nullable_variant_class_ = std::move(nullable_variant_class);
}

std::optional<std::variant<VDerivedClass1*, VDerivedClass2*>> VNode::optional_variant_class() {
  if (!optional_variant_class_.has_value()) {
    return std::nullopt;
  } else {
    switch (optional_variant_class_.value().index()) {
      case 0: {
        return std::get<0>(optional_variant_class_.value()).get();
      }
      case 1: {
        return std::get<1>(optional_variant_class_.value()).get();
      }
      default:
        LOG(FATAL) << "Unreachable code.";
    }
  }
}

std::optional<std::variant<const VDerivedClass1*, const VDerivedClass2*>> VNode::optional_variant_class() const {
  if (!optional_variant_class_.has_value()) {
    return std::nullopt;
  } else {
    switch (optional_variant_class_.value().index()) {
      case 0: {
        return std::get<0>(optional_variant_class_.value()).get();
      }
      case 1: {
        return std::get<1>(optional_variant_class_.value()).get();
      }
      default:
        LOG(FATAL) << "Unreachable code.";
    }
  }
}

void VNode::set_optional_variant_class(std::optional<std::variant<std::unique_ptr<VDerivedClass1>, std::unique_ptr<VDerivedClass2>>> optional_variant_class) {
  optional_variant_class_ = std::move(optional_variant_class);
}

// clang-format on
// NOLINTEND(whitespace/line_length)
// IWYU pragma: end_keep

}  // namespace maldoca
