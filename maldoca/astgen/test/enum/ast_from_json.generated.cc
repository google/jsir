// Copyright 2024 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// =============================================================================
// STOP!! DO NOT MODIFY!! THIS FILE IS AUTOMATICALLY GENERATED.
// =============================================================================

// NOLINTBEGIN(whitespace/line_length)
// clang-format off
// IWYU pragma: begin_keep

#include <cstdint>
#include <memory>
#include <optional>
#include <string>
#include <utility>
#include <variant>
#include <vector>

#include "maldoca/astgen/test/enum/ast.generated.h"
#include "absl/container/flat_hash_set.h"
#include "absl/memory/memory.h"
#include "absl/status/status.h"
#include "absl/status/statusor.h"
#include "absl/strings/str_cat.h"
#include "absl/strings/string_view.h"
#include "maldoca/base/status_macros.h"
#include "nlohmann/json.hpp"

namespace maldoca {

// =============================================================================
// ENode
// =============================================================================

absl::StatusOr<EUnaryOperator>
ENode::GetUnaryOperator(const nlohmann::json& json) {
  auto unary_operator_it = json.find("unaryOperator");
  if (unary_operator_it == json.end()) {
    return absl::InvalidArgumentError("`unaryOperator` is undefined.");
  }
  const nlohmann::json& json_unary_operator = unary_operator_it.value();

  if (json_unary_operator.is_null()) {
    return absl::InvalidArgumentError("json_unary_operator is null.");
  }
  if (!json_unary_operator.is_string()) {
    return absl::InvalidArgumentError("`json_unary_operator` expected to be a string.");
  }
  std::string json_unary_operator_str = json_unary_operator.get<std::string>();
  return StringToEUnaryOperator(json_unary_operator_str);
}

absl::StatusOr<EEscapedChar>
ENode::GetEscapedChar(const nlohmann::json& json) {
  auto escaped_char_it = json.find("escapedChar");
  if (escaped_char_it == json.end()) {
    return absl::InvalidArgumentError("`escapedChar` is undefined.");
  }
  const nlohmann::json& json_escaped_char = escaped_char_it.value();

  if (json_escaped_char.is_null()) {
    return absl::InvalidArgumentError("json_escaped_char is null.");
  }
  if (!json_escaped_char.is_string()) {
    return absl::InvalidArgumentError("`json_escaped_char` expected to be a string.");
  }
  std::string json_escaped_char_str = json_escaped_char.get<std::string>();
  return StringToEEscapedChar(json_escaped_char_str);
}

absl::StatusOr<std::unique_ptr<ENode>>
ENode::FromJson(const nlohmann::json& json) {
  if (!json.is_object()) {
    return absl::InvalidArgumentError("JSON is not an object.");
  }

  MALDOCA_ASSIGN_OR_RETURN(auto unary_operator, ENode::GetUnaryOperator(json));
  MALDOCA_ASSIGN_OR_RETURN(auto escaped_char, ENode::GetEscapedChar(json));

  return absl::make_unique<ENode>(
      std::move(unary_operator),
      std::move(escaped_char));
}

// clang-format on
// NOLINTEND(whitespace/line_length)
// IWYU pragma: end_keep

}  // namespace maldoca
