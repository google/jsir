// Copyright 2024 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// =============================================================================
// STOP!! DO NOT MODIFY!! THIS FILE IS AUTOMATICALLY GENERATED.
// =============================================================================

#include "maldoca/astgen/test/enum/ast.generated.h"

// IWYU pragma: begin_keep
// NOLINTBEGIN(whitespace/line_length)
// clang-format off

#include <cstdint>
#include <memory>
#include <optional>
#include <string>
#include <utility>
#include <variant>
#include <vector>

#include "absl/container/flat_hash_map.h"
#include "absl/memory/memory.h"
#include "absl/log/log.h"
#include "absl/status/status.h"
#include "absl/status/statusor.h"
#include "absl/strings/str_cat.h"
#include "absl/strings/string_view.h"
#include "nlohmann/json.hpp"
#include "maldoca/base/status_macros.h"

namespace maldoca {

absl::string_view EUnaryOperatorToString(EUnaryOperator unary_operator) {
  switch (unary_operator) {
    case EUnaryOperator::kMinus:
      return "-";
    case EUnaryOperator::kPlus:
      return "+";
    case EUnaryOperator::kNot:
      return "!";
    case EUnaryOperator::kBitwiseNot:
      return "~";
    case EUnaryOperator::kTypeOf:
      return "typeof";
    case EUnaryOperator::kVoid:
      return "void";
    case EUnaryOperator::kDelete:
      return "delete";
    case EUnaryOperator::kThrow:
      return "throw";
  }
}

absl::StatusOr<EUnaryOperator> StringToEUnaryOperator(absl::string_view s) {
  static const auto *kMap = new absl::flat_hash_map<absl::string_view, EUnaryOperator> {
      {"-", EUnaryOperator::kMinus},
      {"+", EUnaryOperator::kPlus},
      {"!", EUnaryOperator::kNot},
      {"~", EUnaryOperator::kBitwiseNot},
      {"typeof", EUnaryOperator::kTypeOf},
      {"void", EUnaryOperator::kVoid},
      {"delete", EUnaryOperator::kDelete},
      {"throw", EUnaryOperator::kThrow},
  };

  auto it = kMap->find(s);
  if (it == kMap->end()) {
    return absl::InvalidArgumentError(absl::StrCat("Invalid string for EUnaryOperator: ", s));
  }
  return it->second;
}

absl::string_view EEscapedCharToString(EEscapedChar escaped_char) {
  switch (escaped_char) {
    case EEscapedChar::kTab:
      return "\t";
    case EEscapedChar::kBackslash:
      return "\\";
  }
}

absl::StatusOr<EEscapedChar> StringToEEscapedChar(absl::string_view s) {
  static const auto *kMap = new absl::flat_hash_map<absl::string_view, EEscapedChar> {
      {"\t", EEscapedChar::kTab},
      {"\\", EEscapedChar::kBackslash},
  };

  auto it = kMap->find(s);
  if (it == kMap->end()) {
    return absl::InvalidArgumentError(absl::StrCat("Invalid string for EEscapedChar: ", s));
  }
  return it->second;
}

// =============================================================================
// ENode
// =============================================================================

ENode::ENode(
    EUnaryOperator unary_operator,
    EEscapedChar escaped_char)
    : unary_operator_(std::move(unary_operator)),
      escaped_char_(std::move(escaped_char)) {}

EUnaryOperator ENode::unary_operator() const {
  return unary_operator_;
}

void ENode::set_unary_operator(EUnaryOperator unary_operator) {
  unary_operator_ = unary_operator;
}

EEscapedChar ENode::escaped_char() const {
  return escaped_char_;
}

void ENode::set_escaped_char(EEscapedChar escaped_char) {
  escaped_char_ = escaped_char;
}

// clang-format on
// NOLINTEND(whitespace/line_length)
// IWYU pragma: end_keep

}  // namespace maldoca
