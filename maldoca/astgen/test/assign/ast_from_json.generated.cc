// Copyright 2024 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// =============================================================================
// STOP!! DO NOT MODIFY!! THIS FILE IS AUTOMATICALLY GENERATED.
// =============================================================================

// NOLINTBEGIN(whitespace/line_length)
// clang-format off
// IWYU pragma: begin_keep

#include <cstdint>
#include <memory>
#include <optional>
#include <string>
#include <utility>
#include <variant>
#include <vector>

#include "maldoca/astgen/test/assign/ast.generated.h"
#include "absl/container/flat_hash_set.h"
#include "absl/memory/memory.h"
#include "absl/status/status.h"
#include "absl/status/statusor.h"
#include "absl/strings/str_cat.h"
#include "absl/strings/string_view.h"
#include "maldoca/base/status_macros.h"
#include "nlohmann/json.hpp"

namespace maldoca {

static absl::StatusOr<std::string> GetType(const nlohmann::json& json) {
  auto type_it = json.find("type");
  if (type_it == json.end()) {
    return absl::InvalidArgumentError("`type` is undefined.");
  }
  const nlohmann::json& json_type = type_it.value();
  if (json_type.is_null()) {
    return absl::InvalidArgumentError("json_type is null.");
  }
  if (!json_type.is_string()) {
    return absl::InvalidArgumentError("`json_type` expected to be string.");
  }
  return json_type.get<std::string>();
}

// =============================================================================
// AExpression
// =============================================================================

absl::StatusOr<std::unique_ptr<AExpression>>
AExpression::FromJson(const nlohmann::json& json) {
  if (!json.is_object()) {
    return absl::InvalidArgumentError("JSON is not an object.");
  }

  MALDOCA_ASSIGN_OR_RETURN(std::string type, GetType(json));

  if (type == "Identifier") {
    return AIdentifier::FromJson(json);
  } else if (type == "Assignment") {
    return AAssignment::FromJson(json);
  }
  return absl::InvalidArgumentError(absl::StrCat("Invalid type: ", type));
}

// =============================================================================
// AIdentifier
// =============================================================================

absl::StatusOr<std::string>
AIdentifier::GetName(const nlohmann::json& json) {
  auto name_it = json.find("name");
  if (name_it == json.end()) {
    return absl::InvalidArgumentError("`name` is undefined.");
  }
  const nlohmann::json& json_name = name_it.value();

  if (json_name.is_null()) {
    return absl::InvalidArgumentError("json_name is null.");
  }
  if (!json_name.is_string()) {
    return absl::InvalidArgumentError("Expecting json_name.is_string().");
  }
  return json_name.get<std::string>();
}

absl::StatusOr<std::unique_ptr<AIdentifier>>
AIdentifier::FromJson(const nlohmann::json& json) {
  if (!json.is_object()) {
    return absl::InvalidArgumentError("JSON is not an object.");
  }

  MALDOCA_ASSIGN_OR_RETURN(auto name, AIdentifier::GetName(json));

  return absl::make_unique<AIdentifier>(
      std::move(name));
}

// =============================================================================
// AAssignment
// =============================================================================

absl::StatusOr<std::unique_ptr<AIdentifier>>
AAssignment::GetLhs(const nlohmann::json& json) {
  auto lhs_it = json.find("lhs");
  if (lhs_it == json.end()) {
    return absl::InvalidArgumentError("`lhs` is undefined.");
  }
  const nlohmann::json& json_lhs = lhs_it.value();

  if (json_lhs.is_null()) {
    return absl::InvalidArgumentError("json_lhs is null.");
  }
  return AIdentifier::FromJson(json_lhs);
}

absl::StatusOr<std::unique_ptr<AExpression>>
AAssignment::GetRhs(const nlohmann::json& json) {
  auto rhs_it = json.find("rhs");
  if (rhs_it == json.end()) {
    return absl::InvalidArgumentError("`rhs` is undefined.");
  }
  const nlohmann::json& json_rhs = rhs_it.value();

  if (json_rhs.is_null()) {
    return absl::InvalidArgumentError("json_rhs is null.");
  }
  return AExpression::FromJson(json_rhs);
}

absl::StatusOr<std::unique_ptr<AAssignment>>
AAssignment::FromJson(const nlohmann::json& json) {
  if (!json.is_object()) {
    return absl::InvalidArgumentError("JSON is not an object.");
  }

  MALDOCA_ASSIGN_OR_RETURN(auto lhs, AAssignment::GetLhs(json));
  MALDOCA_ASSIGN_OR_RETURN(auto rhs, AAssignment::GetRhs(json));

  return absl::make_unique<AAssignment>(
      std::move(lhs),
      std::move(rhs));
}

// clang-format on
// NOLINTEND(whitespace/line_length)
// IWYU pragma: end_keep

}  // namespace maldoca
