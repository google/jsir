// Copyright 2024 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// =============================================================================
// STOP!! DO NOT MODIFY!! THIS FILE IS AUTOMATICALLY GENERATED.
// =============================================================================

// NOLINTBEGIN(whitespace/line_length)
// clang-format off
// IWYU pragma: begin_keep

#include <cstdint>
#include <memory>
#include <optional>
#include <string>
#include <utility>
#include <variant>
#include <vector>

#include "maldoca/astgen/test/typed_lambda/ast.generated.h"
#include "absl/container/flat_hash_set.h"
#include "absl/memory/memory.h"
#include "absl/status/status.h"
#include "absl/status/statusor.h"
#include "absl/strings/str_cat.h"
#include "absl/strings/string_view.h"
#include "maldoca/base/status_macros.h"
#include "nlohmann/json.hpp"

namespace maldoca {

static absl::StatusOr<std::string> GetType(const nlohmann::json& json) {
  auto type_it = json.find("type");
  if (type_it == json.end()) {
    return absl::InvalidArgumentError("`type` is undefined.");
  }
  const nlohmann::json& json_type = type_it.value();
  if (json_type.is_null()) {
    return absl::InvalidArgumentError("json_type is null.");
  }
  if (!json_type.is_string()) {
    return absl::InvalidArgumentError("`json_type` expected to be string.");
  }
  return json_type.get<std::string>();
}

// =============================================================================
// TlNode
// =============================================================================

absl::StatusOr<std::unique_ptr<TlNode>>
TlNode::FromJson(const nlohmann::json& json) {
  if (!json.is_object()) {
    return absl::InvalidArgumentError("JSON is not an object.");
  }

  MALDOCA_ASSIGN_OR_RETURN(std::string type, GetType(json));

  if (type == "Literal") {
    return TlLiteral::FromJson(json);
  } else if (type == "Variable") {
    return TlVariable::FromJson(json);
  } else if (type == "FunctionDefinition") {
    return TlFunctionDefinition::FromJson(json);
  } else if (type == "FunctionCall") {
    return TlFunctionCall::FromJson(json);
  } else if (type == "Expression") {
    return TlExpression::FromJson(json);
  } else if (type == "LiteralType") {
    return TlLiteralType::FromJson(json);
  } else if (type == "FunctionType") {
    return TlFunctionType::FromJson(json);
  } else if (type == "Type") {
    return TlType::FromJson(json);
  }
  return absl::InvalidArgumentError(absl::StrCat("Invalid type: ", type));
}

// =============================================================================
// TlExpression
// =============================================================================

absl::StatusOr<std::unique_ptr<TlExpression>>
TlExpression::FromJson(const nlohmann::json& json) {
  if (!json.is_object()) {
    return absl::InvalidArgumentError("JSON is not an object.");
  }

  MALDOCA_ASSIGN_OR_RETURN(std::string type, GetType(json));

  if (type == "Literal") {
    return TlLiteral::FromJson(json);
  } else if (type == "Variable") {
    return TlVariable::FromJson(json);
  } else if (type == "FunctionDefinition") {
    return TlFunctionDefinition::FromJson(json);
  } else if (type == "FunctionCall") {
    return TlFunctionCall::FromJson(json);
  }
  return absl::InvalidArgumentError(absl::StrCat("Invalid type: ", type));
}

// =============================================================================
// TlType
// =============================================================================

absl::StatusOr<std::unique_ptr<TlType>>
TlType::FromJson(const nlohmann::json& json) {
  if (!json.is_object()) {
    return absl::InvalidArgumentError("JSON is not an object.");
  }

  MALDOCA_ASSIGN_OR_RETURN(std::string type, GetType(json));

  if (type == "LiteralType") {
    return TlLiteralType::FromJson(json);
  } else if (type == "FunctionType") {
    return TlFunctionType::FromJson(json);
  }
  return absl::InvalidArgumentError(absl::StrCat("Invalid type: ", type));
}

// =============================================================================
// TlLiteral
// =============================================================================

absl::StatusOr<std::variant<bool, int64_t, double, std::string>>
TlLiteral::GetValue(const nlohmann::json& json) {
  auto value_it = json.find("value");
  if (value_it == json.end()) {
    return absl::InvalidArgumentError("`value` is undefined.");
  }
  const nlohmann::json& json_value = value_it.value();

  if (json_value.is_null()) {
    return absl::InvalidArgumentError("json_value is null.");
  }
  if (json_value.is_boolean()) {
    return json_value.get<bool>();
  } else if (json_value.is_number_integer()) {
    return json_value.get<int64_t>();
  } else if (json_value.is_number()) {
    return json_value.get<double>();
  } else if (json_value.is_string()) {
    return json_value.get<std::string>();
  } else {
    auto result = absl::InvalidArgumentError("json_value has invalid type.");
    result.SetPayload("json", absl::Cord{json.dump()});
    result.SetPayload("json_element", absl::Cord{json_value.dump()});
    return result;
  }
}

absl::StatusOr<std::unique_ptr<TlLiteral>>
TlLiteral::FromJson(const nlohmann::json& json) {
  if (!json.is_object()) {
    return absl::InvalidArgumentError("JSON is not an object.");
  }

  MALDOCA_ASSIGN_OR_RETURN(auto value, TlLiteral::GetValue(json));

  return absl::make_unique<TlLiteral>(
      std::move(value));
}

// =============================================================================
// TlVariable
// =============================================================================

absl::StatusOr<std::string>
TlVariable::GetIdentifier(const nlohmann::json& json) {
  auto identifier_it = json.find("identifier");
  if (identifier_it == json.end()) {
    return absl::InvalidArgumentError("`identifier` is undefined.");
  }
  const nlohmann::json& json_identifier = identifier_it.value();

  if (json_identifier.is_null()) {
    return absl::InvalidArgumentError("json_identifier is null.");
  }
  if (!json_identifier.is_string()) {
    return absl::InvalidArgumentError("Expecting json_identifier.is_string().");
  }
  return json_identifier.get<std::string>();
}

absl::StatusOr<std::unique_ptr<TlVariable>>
TlVariable::FromJson(const nlohmann::json& json) {
  if (!json.is_object()) {
    return absl::InvalidArgumentError("JSON is not an object.");
  }

  MALDOCA_ASSIGN_OR_RETURN(auto identifier, TlVariable::GetIdentifier(json));

  return absl::make_unique<TlVariable>(
      std::move(identifier));
}

// =============================================================================
// TlFunctionDefinition
// =============================================================================

absl::StatusOr<std::unique_ptr<TlVariable>>
TlFunctionDefinition::GetParameter(const nlohmann::json& json) {
  auto parameter_it = json.find("parameter");
  if (parameter_it == json.end()) {
    return absl::InvalidArgumentError("`parameter` is undefined.");
  }
  const nlohmann::json& json_parameter = parameter_it.value();

  if (json_parameter.is_null()) {
    return absl::InvalidArgumentError("json_parameter is null.");
  }
  return TlVariable::FromJson(json_parameter);
}

absl::StatusOr<std::unique_ptr<TlType>>
TlFunctionDefinition::GetParameterType(const nlohmann::json& json) {
  auto parameter_type_it = json.find("parameterType");
  if (parameter_type_it == json.end()) {
    return absl::InvalidArgumentError("`parameterType` is undefined.");
  }
  const nlohmann::json& json_parameter_type = parameter_type_it.value();

  if (json_parameter_type.is_null()) {
    return absl::InvalidArgumentError("json_parameter_type is null.");
  }
  return TlType::FromJson(json_parameter_type);
}

absl::StatusOr<std::unique_ptr<TlExpression>>
TlFunctionDefinition::GetBody(const nlohmann::json& json) {
  auto body_it = json.find("body");
  if (body_it == json.end()) {
    return absl::InvalidArgumentError("`body` is undefined.");
  }
  const nlohmann::json& json_body = body_it.value();

  if (json_body.is_null()) {
    return absl::InvalidArgumentError("json_body is null.");
  }
  return TlExpression::FromJson(json_body);
}

absl::StatusOr<std::unique_ptr<TlFunctionDefinition>>
TlFunctionDefinition::FromJson(const nlohmann::json& json) {
  if (!json.is_object()) {
    return absl::InvalidArgumentError("JSON is not an object.");
  }

  MALDOCA_ASSIGN_OR_RETURN(auto parameter, TlFunctionDefinition::GetParameter(json));
  MALDOCA_ASSIGN_OR_RETURN(auto parameter_type, TlFunctionDefinition::GetParameterType(json));
  MALDOCA_ASSIGN_OR_RETURN(auto body, TlFunctionDefinition::GetBody(json));

  return absl::make_unique<TlFunctionDefinition>(
      std::move(parameter),
      std::move(parameter_type),
      std::move(body));
}

// =============================================================================
// TlFunctionCall
// =============================================================================

absl::StatusOr<std::unique_ptr<TlExpression>>
TlFunctionCall::GetCaller(const nlohmann::json& json) {
  auto caller_it = json.find("caller");
  if (caller_it == json.end()) {
    return absl::InvalidArgumentError("`caller` is undefined.");
  }
  const nlohmann::json& json_caller = caller_it.value();

  if (json_caller.is_null()) {
    return absl::InvalidArgumentError("json_caller is null.");
  }
  return TlExpression::FromJson(json_caller);
}

absl::StatusOr<std::unique_ptr<TlExpression>>
TlFunctionCall::GetCallee(const nlohmann::json& json) {
  auto callee_it = json.find("callee");
  if (callee_it == json.end()) {
    return absl::InvalidArgumentError("`callee` is undefined.");
  }
  const nlohmann::json& json_callee = callee_it.value();

  if (json_callee.is_null()) {
    return absl::InvalidArgumentError("json_callee is null.");
  }
  return TlExpression::FromJson(json_callee);
}

absl::StatusOr<std::unique_ptr<TlFunctionCall>>
TlFunctionCall::FromJson(const nlohmann::json& json) {
  if (!json.is_object()) {
    return absl::InvalidArgumentError("JSON is not an object.");
  }

  MALDOCA_ASSIGN_OR_RETURN(auto caller, TlFunctionCall::GetCaller(json));
  MALDOCA_ASSIGN_OR_RETURN(auto callee, TlFunctionCall::GetCallee(json));

  return absl::make_unique<TlFunctionCall>(
      std::move(caller),
      std::move(callee));
}

// =============================================================================
// TlLiteralType
// =============================================================================

absl::StatusOr<std::unique_ptr<TlLiteralType>>
TlLiteralType::FromJson(const nlohmann::json& json) {
  if (!json.is_object()) {
    return absl::InvalidArgumentError("JSON is not an object.");
  }


  return absl::make_unique<TlLiteralType>(
  );
}

// =============================================================================
// TlFunctionType
// =============================================================================

absl::StatusOr<std::unique_ptr<TlType>>
TlFunctionType::GetParameterType(const nlohmann::json& json) {
  auto parameter_type_it = json.find("parameterType");
  if (parameter_type_it == json.end()) {
    return absl::InvalidArgumentError("`parameterType` is undefined.");
  }
  const nlohmann::json& json_parameter_type = parameter_type_it.value();

  if (json_parameter_type.is_null()) {
    return absl::InvalidArgumentError("json_parameter_type is null.");
  }
  return TlType::FromJson(json_parameter_type);
}

absl::StatusOr<std::unique_ptr<TlType>>
TlFunctionType::GetBodyType(const nlohmann::json& json) {
  auto body_type_it = json.find("bodyType");
  if (body_type_it == json.end()) {
    return absl::InvalidArgumentError("`bodyType` is undefined.");
  }
  const nlohmann::json& json_body_type = body_type_it.value();

  if (json_body_type.is_null()) {
    return absl::InvalidArgumentError("json_body_type is null.");
  }
  return TlType::FromJson(json_body_type);
}

absl::StatusOr<std::unique_ptr<TlFunctionType>>
TlFunctionType::FromJson(const nlohmann::json& json) {
  if (!json.is_object()) {
    return absl::InvalidArgumentError("JSON is not an object.");
  }

  MALDOCA_ASSIGN_OR_RETURN(auto parameter_type, TlFunctionType::GetParameterType(json));
  MALDOCA_ASSIGN_OR_RETURN(auto body_type, TlFunctionType::GetBodyType(json));

  return absl::make_unique<TlFunctionType>(
      std::move(parameter_type),
      std::move(body_type));
}

// clang-format on
// NOLINTEND(whitespace/line_length)
// IWYU pragma: end_keep

}  // namespace maldoca
