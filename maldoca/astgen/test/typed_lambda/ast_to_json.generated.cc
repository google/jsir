// Copyright 2024 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// =============================================================================
// STOP!! DO NOT MODIFY!! THIS FILE IS AUTOMATICALLY GENERATED.
// =============================================================================

// IWYU pragma: begin_keep
// NOLINTBEGIN(whitespace/line_length)
// clang-format off

#include <cmath>
#include <limits>
#include <ostream>
#include <string>
#include <utility>

#include "maldoca/astgen/test/typed_lambda/ast.generated.h"
#include "absl/log/log.h"
#include "absl/memory/memory.h"
#include "absl/status/status.h"
#include "absl/strings/string_view.h"
#include "nlohmann/json.hpp"
#include "maldoca/base/status_macros.h"

namespace maldoca {

void MaybeAddComma(std::ostream &os, bool &needs_comma) {
  if (needs_comma) {
    os << ",";
  }
  needs_comma = true;
}

// =============================================================================
// TlNode
// =============================================================================

void TlNode::SerializeFields(std::ostream& os, bool &needs_comma) const {
}

// =============================================================================
// TlExpression
// =============================================================================

void TlExpression::SerializeFields(std::ostream& os, bool &needs_comma) const {
}

// =============================================================================
// TlType
// =============================================================================

void TlType::SerializeFields(std::ostream& os, bool &needs_comma) const {
}

// =============================================================================
// TlLiteral
// =============================================================================

void TlLiteral::SerializeFields(std::ostream& os, bool &needs_comma) const {
  MaybeAddComma(os, needs_comma);
  switch (value_.index()) {
    case 0: {
      os << "\"value\":" << (nlohmann::json(std::get<0>(value_))).dump();
      break;
    }
    case 1: {
      os << "\"value\":" << (nlohmann::json(std::get<1>(value_))).dump();
      break;
    }
    case 2: {
      os << "\"value\":" << (nlohmann::json(std::get<2>(value_))).dump();
      break;
    }
    case 3: {
      os << "\"value\":" << (nlohmann::json(std::get<3>(value_))).dump();
      break;
    }
    default:
      LOG(FATAL) << "Unreachable code.";
  }
}

void TlLiteral::Serialize(std::ostream& os) const {
  os << "{";
  {
    bool needs_comma = false;
    MaybeAddComma(os, needs_comma);
    os << "\"type\":\"Literal\"";
    TlNode::SerializeFields(os, needs_comma);
    TlExpression::SerializeFields(os, needs_comma);
    TlLiteral::SerializeFields(os, needs_comma);
  }
  os << "}";
}

// =============================================================================
// TlVariable
// =============================================================================

void TlVariable::SerializeFields(std::ostream& os, bool &needs_comma) const {
  MaybeAddComma(os, needs_comma);
  os << "\"identifier\":" << (nlohmann::json(identifier_)).dump();
}

void TlVariable::Serialize(std::ostream& os) const {
  os << "{";
  {
    bool needs_comma = false;
    MaybeAddComma(os, needs_comma);
    os << "\"type\":\"Variable\"";
    TlNode::SerializeFields(os, needs_comma);
    TlExpression::SerializeFields(os, needs_comma);
    TlVariable::SerializeFields(os, needs_comma);
  }
  os << "}";
}

// =============================================================================
// TlFunctionDefinition
// =============================================================================

void TlFunctionDefinition::SerializeFields(std::ostream& os, bool &needs_comma) const {
  MaybeAddComma(os, needs_comma);
  os << "\"parameter\":";
  parameter_->Serialize(os);
  MaybeAddComma(os, needs_comma);
  os << "\"parameterType\":";
  parameter_type_->Serialize(os);
  MaybeAddComma(os, needs_comma);
  os << "\"body\":";
  body_->Serialize(os);
}

void TlFunctionDefinition::Serialize(std::ostream& os) const {
  os << "{";
  {
    bool needs_comma = false;
    MaybeAddComma(os, needs_comma);
    os << "\"type\":\"FunctionDefinition\"";
    TlNode::SerializeFields(os, needs_comma);
    TlExpression::SerializeFields(os, needs_comma);
    TlFunctionDefinition::SerializeFields(os, needs_comma);
  }
  os << "}";
}

// =============================================================================
// TlFunctionCall
// =============================================================================

void TlFunctionCall::SerializeFields(std::ostream& os, bool &needs_comma) const {
  MaybeAddComma(os, needs_comma);
  os << "\"caller\":";
  caller_->Serialize(os);
  MaybeAddComma(os, needs_comma);
  os << "\"callee\":";
  callee_->Serialize(os);
}

void TlFunctionCall::Serialize(std::ostream& os) const {
  os << "{";
  {
    bool needs_comma = false;
    MaybeAddComma(os, needs_comma);
    os << "\"type\":\"FunctionCall\"";
    TlNode::SerializeFields(os, needs_comma);
    TlExpression::SerializeFields(os, needs_comma);
    TlFunctionCall::SerializeFields(os, needs_comma);
  }
  os << "}";
}

// =============================================================================
// TlLiteralType
// =============================================================================

void TlLiteralType::SerializeFields(std::ostream& os, bool &needs_comma) const {
}

void TlLiteralType::Serialize(std::ostream& os) const {
  os << "{";
  {
    bool needs_comma = false;
    MaybeAddComma(os, needs_comma);
    os << "\"type\":\"LiteralType\"";
    TlNode::SerializeFields(os, needs_comma);
    TlType::SerializeFields(os, needs_comma);
    TlLiteralType::SerializeFields(os, needs_comma);
  }
  os << "}";
}

// =============================================================================
// TlFunctionType
// =============================================================================

void TlFunctionType::SerializeFields(std::ostream& os, bool &needs_comma) const {
  MaybeAddComma(os, needs_comma);
  os << "\"parameterType\":";
  parameter_type_->Serialize(os);
  MaybeAddComma(os, needs_comma);
  os << "\"bodyType\":";
  body_type_->Serialize(os);
}

void TlFunctionType::Serialize(std::ostream& os) const {
  os << "{";
  {
    bool needs_comma = false;
    MaybeAddComma(os, needs_comma);
    os << "\"type\":\"FunctionType\"";
    TlNode::SerializeFields(os, needs_comma);
    TlType::SerializeFields(os, needs_comma);
    TlFunctionType::SerializeFields(os, needs_comma);
  }
  os << "}";
}

// clang-format on
// NOLINTEND(whitespace/line_length)
// IWYU pragma: end_keep

}  // namespace maldoca
