// Copyright 2024 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// =============================================================================
// STOP!! DO NOT MODIFY!! THIS FILE IS AUTOMATICALLY GENERATED.
// =============================================================================

#include "maldoca/astgen/test/typed_lambda/ast.generated.h"

// IWYU pragma: begin_keep
// NOLINTBEGIN(whitespace/line_length)
// clang-format off

#include <cstdint>
#include <memory>
#include <optional>
#include <string>
#include <utility>
#include <variant>
#include <vector>

#include "absl/container/flat_hash_map.h"
#include "absl/memory/memory.h"
#include "absl/log/log.h"
#include "absl/status/status.h"
#include "absl/status/statusor.h"
#include "absl/strings/str_cat.h"
#include "absl/strings/string_view.h"
#include "nlohmann/json.hpp"
#include "maldoca/base/status_macros.h"

namespace maldoca {

// =============================================================================
// TlNode
// =============================================================================

absl::string_view TlNodeTypeToString(TlNodeType node_type) {
  switch (node_type) {
    case TlNodeType::kLiteral:
      return "Literal";
    case TlNodeType::kVariable:
      return "Variable";
    case TlNodeType::kFunctionDefinition:
      return "FunctionDefinition";
    case TlNodeType::kFunctionCall:
      return "FunctionCall";
    case TlNodeType::kLiteralType:
      return "LiteralType";
    case TlNodeType::kFunctionType:
      return "FunctionType";
  }
}

absl::StatusOr<TlNodeType> StringToTlNodeType(absl::string_view s) {
  static const auto *kMap = new absl::flat_hash_map<absl::string_view, TlNodeType> {
      {"Literal", TlNodeType::kLiteral},
      {"Variable", TlNodeType::kVariable},
      {"FunctionDefinition", TlNodeType::kFunctionDefinition},
      {"FunctionCall", TlNodeType::kFunctionCall},
      {"LiteralType", TlNodeType::kLiteralType},
      {"FunctionType", TlNodeType::kFunctionType},
  };

  auto it = kMap->find(s);
  if (it == kMap->end()) {
    return absl::InvalidArgumentError(absl::StrCat("Invalid string for TlNodeType: ", s));
  }
  return it->second;
}

// =============================================================================
// TlExpression
// =============================================================================

// =============================================================================
// TlType
// =============================================================================

// =============================================================================
// TlLiteral
// =============================================================================

TlLiteral::TlLiteral(
    std::variant<bool, int64_t, double, std::string> value)
    : TlNode(),
      TlExpression(),
      value_(std::move(value)) {}

std::variant<bool, int64_t, double, absl::string_view> TlLiteral::value() const {
  switch (value_.index()) {
    case 0: {
      return std::get<0>(value_);
    }
    case 1: {
      return std::get<1>(value_);
    }
    case 2: {
      return std::get<2>(value_);
    }
    case 3: {
      return std::get<3>(value_);
    }
    default:
      LOG(FATAL) << "Unreachable code.";
  }
}

void TlLiteral::set_value(std::variant<bool, int64_t, double, std::string> value) {
  value_ = std::move(value);
}

// =============================================================================
// TlVariable
// =============================================================================

TlVariable::TlVariable(
    std::string identifier)
    : TlNode(),
      TlExpression(),
      identifier_(std::move(identifier)) {}

absl::string_view TlVariable::identifier() const {
  return identifier_;
}

void TlVariable::set_identifier(std::string identifier) {
  identifier_ = std::move(identifier);
}

// =============================================================================
// TlFunctionDefinition
// =============================================================================

TlFunctionDefinition::TlFunctionDefinition(
    std::unique_ptr<TlVariable> parameter,
    std::unique_ptr<TlType> parameter_type,
    std::unique_ptr<TlExpression> body)
    : TlNode(),
      TlExpression(),
      parameter_(std::move(parameter)),
      parameter_type_(std::move(parameter_type)),
      body_(std::move(body)) {}

TlVariable* TlFunctionDefinition::parameter() {
  return parameter_.get();
}

const TlVariable* TlFunctionDefinition::parameter() const {
  return parameter_.get();
}

void TlFunctionDefinition::set_parameter(std::unique_ptr<TlVariable> parameter) {
  parameter_ = std::move(parameter);
}

TlType* TlFunctionDefinition::parameter_type() {
  return parameter_type_.get();
}

const TlType* TlFunctionDefinition::parameter_type() const {
  return parameter_type_.get();
}

void TlFunctionDefinition::set_parameter_type(std::unique_ptr<TlType> parameter_type) {
  parameter_type_ = std::move(parameter_type);
}

TlExpression* TlFunctionDefinition::body() {
  return body_.get();
}

const TlExpression* TlFunctionDefinition::body() const {
  return body_.get();
}

void TlFunctionDefinition::set_body(std::unique_ptr<TlExpression> body) {
  body_ = std::move(body);
}

// =============================================================================
// TlFunctionCall
// =============================================================================

TlFunctionCall::TlFunctionCall(
    std::unique_ptr<TlExpression> caller,
    std::unique_ptr<TlExpression> callee)
    : TlNode(),
      TlExpression(),
      caller_(std::move(caller)),
      callee_(std::move(callee)) {}

TlExpression* TlFunctionCall::caller() {
  return caller_.get();
}

const TlExpression* TlFunctionCall::caller() const {
  return caller_.get();
}

void TlFunctionCall::set_caller(std::unique_ptr<TlExpression> caller) {
  caller_ = std::move(caller);
}

TlExpression* TlFunctionCall::callee() {
  return callee_.get();
}

const TlExpression* TlFunctionCall::callee() const {
  return callee_.get();
}

void TlFunctionCall::set_callee(std::unique_ptr<TlExpression> callee) {
  callee_ = std::move(callee);
}

// =============================================================================
// TlLiteralType
// =============================================================================

// =============================================================================
// TlFunctionType
// =============================================================================

TlFunctionType::TlFunctionType(
    std::unique_ptr<TlType> parameter_type,
    std::unique_ptr<TlType> body_type)
    : TlNode(),
      TlType(),
      parameter_type_(std::move(parameter_type)),
      body_type_(std::move(body_type)) {}

TlType* TlFunctionType::parameter_type() {
  return parameter_type_.get();
}

const TlType* TlFunctionType::parameter_type() const {
  return parameter_type_.get();
}

void TlFunctionType::set_parameter_type(std::unique_ptr<TlType> parameter_type) {
  parameter_type_ = std::move(parameter_type);
}

TlType* TlFunctionType::body_type() {
  return body_type_.get();
}

const TlType* TlFunctionType::body_type() const {
  return body_type_.get();
}

void TlFunctionType::set_body_type(std::unique_ptr<TlType> body_type) {
  body_type_ = std::move(body_type);
}

// clang-format on
// NOLINTEND(whitespace/line_length)
// IWYU pragma: end_keep

}  // namespace maldoca
