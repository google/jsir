// Copyright 2024 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// =============================================================================
// STOP!! DO NOT MODIFY!! THIS FILE IS AUTOMATICALLY GENERATED.
// =============================================================================

// NOLINTBEGIN(whitespace/line_length)
// clang-format off
// IWYU pragma: begin_keep

#include <cstdint>
#include <memory>
#include <optional>
#include <string>
#include <utility>
#include <variant>
#include <vector>

#include "maldoca/astgen/test/multiple_inheritance/ast.generated.h"
#include "absl/container/flat_hash_set.h"
#include "absl/memory/memory.h"
#include "absl/status/status.h"
#include "absl/status/statusor.h"
#include "absl/strings/str_cat.h"
#include "absl/strings/string_view.h"
#include "maldoca/base/status_macros.h"
#include "nlohmann/json.hpp"

namespace maldoca {

static absl::StatusOr<std::string> GetType(const nlohmann::json& json) {
  auto type_it = json.find("type");
  if (type_it == json.end()) {
    return absl::InvalidArgumentError("`type` is undefined.");
  }
  const nlohmann::json& json_type = type_it.value();
  if (json_type.is_null()) {
    return absl::InvalidArgumentError("json_type is null.");
  }
  if (!json_type.is_string()) {
    return absl::InvalidArgumentError("`json_type` expected to be string.");
  }
  return json_type.get<std::string>();
}

// =============================================================================
// MSourceLocation
// =============================================================================

absl::StatusOr<double>
MSourceLocation::GetStart(const nlohmann::json& json) {
  auto start_it = json.find("start");
  if (start_it == json.end()) {
    return absl::InvalidArgumentError("`start` is undefined.");
  }
  const nlohmann::json& json_start = start_it.value();

  if (json_start.is_null()) {
    return absl::InvalidArgumentError("json_start is null.");
  }
  if (!json_start.is_number()) {
    return absl::InvalidArgumentError("Expecting json_start.is_number().");
  }
  return json_start.get<double>();
}

absl::StatusOr<double>
MSourceLocation::GetEnd(const nlohmann::json& json) {
  auto end_it = json.find("end");
  if (end_it == json.end()) {
    return absl::InvalidArgumentError("`end` is undefined.");
  }
  const nlohmann::json& json_end = end_it.value();

  if (json_end.is_null()) {
    return absl::InvalidArgumentError("json_end is null.");
  }
  if (!json_end.is_number()) {
    return absl::InvalidArgumentError("Expecting json_end.is_number().");
  }
  return json_end.get<double>();
}

absl::StatusOr<std::unique_ptr<MSourceLocation>>
MSourceLocation::FromJson(const nlohmann::json& json) {
  if (!json.is_object()) {
    return absl::InvalidArgumentError("JSON is not an object.");
  }

  MALDOCA_ASSIGN_OR_RETURN(auto start, MSourceLocation::GetStart(json));
  MALDOCA_ASSIGN_OR_RETURN(auto end, MSourceLocation::GetEnd(json));

  return absl::make_unique<MSourceLocation>(
      std::move(start),
      std::move(end));
}

// =============================================================================
// MNode
// =============================================================================

absl::StatusOr<std::unique_ptr<MSourceLocation>>
MNode::GetLoc(const nlohmann::json& json) {
  auto loc_it = json.find("loc");
  if (loc_it == json.end()) {
    return absl::InvalidArgumentError("`loc` is undefined.");
  }
  const nlohmann::json& json_loc = loc_it.value();

  if (json_loc.is_null()) {
    return absl::InvalidArgumentError("json_loc is null.");
  }
  return MSourceLocation::FromJson(json_loc);
}

absl::StatusOr<std::unique_ptr<MNode>>
MNode::FromJson(const nlohmann::json& json) {
  if (!json.is_object()) {
    return absl::InvalidArgumentError("JSON is not an object.");
  }

  MALDOCA_ASSIGN_OR_RETURN(std::string type, GetType(json));

  if (type == "ObjectMethod") {
    return MObjectMethod::FromJson(json);
  } else if (type == "Function") {
    return MFunction::FromJson(json);
  } else if (type == "ObjectMember") {
    return MObjectMember::FromJson(json);
  }
  return absl::InvalidArgumentError(absl::StrCat("Invalid type: ", type));
}

// =============================================================================
// MFunction
// =============================================================================

absl::StatusOr<std::string>
MFunction::GetId(const nlohmann::json& json) {
  auto id_it = json.find("id");
  if (id_it == json.end()) {
    return absl::InvalidArgumentError("`id` is undefined.");
  }
  const nlohmann::json& json_id = id_it.value();

  if (json_id.is_null()) {
    return absl::InvalidArgumentError("json_id is null.");
  }
  if (!json_id.is_string()) {
    return absl::InvalidArgumentError("Expecting json_id.is_string().");
  }
  return json_id.get<std::string>();
}

absl::StatusOr<std::unique_ptr<MFunction>>
MFunction::FromJson(const nlohmann::json& json) {
  if (!json.is_object()) {
    return absl::InvalidArgumentError("JSON is not an object.");
  }

  MALDOCA_ASSIGN_OR_RETURN(std::string type, GetType(json));

  if (type == "ObjectMethod") {
    return MObjectMethod::FromJson(json);
  }
  return absl::InvalidArgumentError(absl::StrCat("Invalid type: ", type));
}

// =============================================================================
// MObjectMember
// =============================================================================

absl::StatusOr<bool>
MObjectMember::GetComputed(const nlohmann::json& json) {
  auto computed_it = json.find("computed");
  if (computed_it == json.end()) {
    return absl::InvalidArgumentError("`computed` is undefined.");
  }
  const nlohmann::json& json_computed = computed_it.value();

  if (json_computed.is_null()) {
    return absl::InvalidArgumentError("json_computed is null.");
  }
  if (!json_computed.is_boolean()) {
    return absl::InvalidArgumentError("Expecting json_computed.is_boolean().");
  }
  return json_computed.get<bool>();
}

absl::StatusOr<std::unique_ptr<MObjectMember>>
MObjectMember::FromJson(const nlohmann::json& json) {
  if (!json.is_object()) {
    return absl::InvalidArgumentError("JSON is not an object.");
  }

  MALDOCA_ASSIGN_OR_RETURN(std::string type, GetType(json));

  if (type == "ObjectMethod") {
    return MObjectMethod::FromJson(json);
  }
  return absl::InvalidArgumentError(absl::StrCat("Invalid type: ", type));
}

// =============================================================================
// MObjectMethod
// =============================================================================

absl::StatusOr<std::unique_ptr<MObjectMethod>>
MObjectMethod::FromJson(const nlohmann::json& json) {
  if (!json.is_object()) {
    return absl::InvalidArgumentError("JSON is not an object.");
  }

  MALDOCA_ASSIGN_OR_RETURN(auto loc, MNode::GetLoc(json));
  MALDOCA_ASSIGN_OR_RETURN(auto computed, MObjectMember::GetComputed(json));
  MALDOCA_ASSIGN_OR_RETURN(auto id, MFunction::GetId(json));

  return absl::make_unique<MObjectMethod>(
      std::move(loc),
      std::move(computed),
      std::move(id));
}

// clang-format on
// NOLINTEND(whitespace/line_length)
// IWYU pragma: end_keep

}  // namespace maldoca
