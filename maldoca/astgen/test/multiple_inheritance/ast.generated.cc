// Copyright 2024 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// =============================================================================
// STOP!! DO NOT MODIFY!! THIS FILE IS AUTOMATICALLY GENERATED.
// =============================================================================

#include "maldoca/astgen/test/multiple_inheritance/ast.generated.h"

// IWYU pragma: begin_keep
// NOLINTBEGIN(whitespace/line_length)
// clang-format off

#include <cstdint>
#include <memory>
#include <optional>
#include <string>
#include <utility>
#include <variant>
#include <vector>

#include "absl/container/flat_hash_map.h"
#include "absl/memory/memory.h"
#include "absl/log/log.h"
#include "absl/status/status.h"
#include "absl/status/statusor.h"
#include "absl/strings/str_cat.h"
#include "absl/strings/string_view.h"
#include "nlohmann/json.hpp"
#include "maldoca/base/status_macros.h"

namespace maldoca {

// =============================================================================
// MSourceLocation
// =============================================================================

MSourceLocation::MSourceLocation(
    double start,
    double end)
    : start_(std::move(start)),
      end_(std::move(end)) {}

double MSourceLocation::start() const {
  return start_;
}

void MSourceLocation::set_start(double start) {
  start_ = start;
}

double MSourceLocation::end() const {
  return end_;
}

void MSourceLocation::set_end(double end) {
  end_ = end;
}

// =============================================================================
// MNode
// =============================================================================

absl::string_view MNodeTypeToString(MNodeType node_type) {
  switch (node_type) {
    case MNodeType::kObjectMethod:
      return "ObjectMethod";
  }
}

absl::StatusOr<MNodeType> StringToMNodeType(absl::string_view s) {
  static const auto *kMap = new absl::flat_hash_map<absl::string_view, MNodeType> {
      {"ObjectMethod", MNodeType::kObjectMethod},
  };

  auto it = kMap->find(s);
  if (it == kMap->end()) {
    return absl::InvalidArgumentError(absl::StrCat("Invalid string for MNodeType: ", s));
  }
  return it->second;
}

MNode::MNode(
    std::unique_ptr<MSourceLocation> loc)
    : loc_(std::move(loc)) {}

MSourceLocation* MNode::loc() {
  return loc_.get();
}

const MSourceLocation* MNode::loc() const {
  return loc_.get();
}

void MNode::set_loc(std::unique_ptr<MSourceLocation> loc) {
  loc_ = std::move(loc);
}

// =============================================================================
// MFunction
// =============================================================================

MFunction::MFunction(
    std::unique_ptr<MSourceLocation> loc,
    std::string id)
    : MNode(std::move(loc)),
      id_(std::move(id)) {}

absl::string_view MFunction::id() const {
  return id_;
}

void MFunction::set_id(std::string id) {
  id_ = std::move(id);
}

// =============================================================================
// MObjectMember
// =============================================================================

MObjectMember::MObjectMember(
    std::unique_ptr<MSourceLocation> loc,
    bool computed)
    : MNode(std::move(loc)),
      computed_(std::move(computed)) {}

bool MObjectMember::computed() const {
  return computed_;
}

void MObjectMember::set_computed(bool computed) {
  computed_ = computed;
}

// =============================================================================
// MObjectMethod
// =============================================================================

MObjectMethod::MObjectMethod(
    std::unique_ptr<MSourceLocation> loc,
    bool computed,
    std::string id)
    : MNode(std::move(loc)),
      MObjectMember(std::move(loc), std::move(computed)),
      MFunction(std::move(loc), std::move(id)) {}

// clang-format on
// NOLINTEND(whitespace/line_length)
// IWYU pragma: end_keep

}  // namespace maldoca
