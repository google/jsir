// Copyright 2024 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// =============================================================================
// STOP!! DO NOT MODIFY!! THIS FILE IS AUTOMATICALLY GENERATED.
// =============================================================================

#ifndef MALDOCA_ASTGEN_TEST_LIST_AST_GENERATED_H_
#define MALDOCA_ASTGEN_TEST_LIST_AST_GENERATED_H_

// IWYU pragma: begin_keep
// NOLINTBEGIN(whitespace/line_length)
// clang-format off

#include <optional>
#include <string>
#include <variant>
#include <vector>

#include "absl/status/statusor.h"
#include "absl/strings/string_view.h"
#include "nlohmann/json.hpp"

namespace maldoca {

class LiClass1 {
 public:
  void Serialize(std::ostream& os) const;

  static absl::StatusOr<std::unique_ptr<LiClass1>> FromJson(const nlohmann::json& json);

 protected:
  // Internal function used by Serialize().
  // Sets the fields defined in this class.
  // Does not set fields defined in ancestors.
  void SerializeFields(std::ostream& os, bool &needs_comma) const;
};

class LiClass2 {
 public:
  void Serialize(std::ostream& os) const;

  static absl::StatusOr<std::unique_ptr<LiClass2>> FromJson(const nlohmann::json& json);

 protected:
  // Internal function used by Serialize().
  // Sets the fields defined in this class.
  // Does not set fields defined in ancestors.
  void SerializeFields(std::ostream& os, bool &needs_comma) const;
};

class LiSimpleList {
 public:
  explicit LiSimpleList(
      std::vector<std::string> strings,
      std::vector<std::unique_ptr<LiClass1>> operations);

  void Serialize(std::ostream& os) const;

  static absl::StatusOr<std::unique_ptr<LiSimpleList>> FromJson(const nlohmann::json& json);

  std::vector<std::string>* strings();
  const std::vector<std::string>* strings() const;
  void set_strings(std::vector<std::string> strings);

  std::vector<std::unique_ptr<LiClass1>>* operations();
  const std::vector<std::unique_ptr<LiClass1>>* operations() const;
  void set_operations(std::vector<std::unique_ptr<LiClass1>> operations);

 protected:
  // Internal function used by Serialize().
  // Sets the fields defined in this class.
  // Does not set fields defined in ancestors.
  void SerializeFields(std::ostream& os, bool &needs_comma) const;

  // Internal functions used by FromJson().
  // Extracts a field from a JSON object.
  static absl::StatusOr<std::vector<std::string>> GetStrings(const nlohmann::json& json);
  static absl::StatusOr<std::vector<std::unique_ptr<LiClass1>>> GetOperations(const nlohmann::json& json);

 private:
  std::vector<std::string> strings_;
  std::vector<std::unique_ptr<LiClass1>> operations_;
};

class LiOptionalList {
 public:
  explicit LiOptionalList(
      std::optional<std::vector<std::string>> strings);

  void Serialize(std::ostream& os) const;

  static absl::StatusOr<std::unique_ptr<LiOptionalList>> FromJson(const nlohmann::json& json);

  std::optional<std::vector<std::string>*> strings();
  std::optional<const std::vector<std::string>*> strings() const;
  void set_strings(std::optional<std::vector<std::string>> strings);

 protected:
  // Internal function used by Serialize().
  // Sets the fields defined in this class.
  // Does not set fields defined in ancestors.
  void SerializeFields(std::ostream& os, bool &needs_comma) const;

  // Internal functions used by FromJson().
  // Extracts a field from a JSON object.
  static absl::StatusOr<std::optional<std::vector<std::string>>> GetStrings(const nlohmann::json& json);

 private:
  std::optional<std::vector<std::string>> strings_;
};

class LiListOfOptional {
 public:
  explicit LiListOfOptional(
      std::vector<std::optional<std::string>> strings,
      std::vector<std::optional<std::unique_ptr<LiClass1>>> operations);

  void Serialize(std::ostream& os) const;

  static absl::StatusOr<std::unique_ptr<LiListOfOptional>> FromJson(const nlohmann::json& json);

  std::vector<std::optional<std::string>>* strings();
  const std::vector<std::optional<std::string>>* strings() const;
  void set_strings(std::vector<std::optional<std::string>> strings);

  std::vector<std::optional<std::unique_ptr<LiClass1>>>* operations();
  const std::vector<std::optional<std::unique_ptr<LiClass1>>>* operations() const;
  void set_operations(std::vector<std::optional<std::unique_ptr<LiClass1>>> operations);

 protected:
  // Internal function used by Serialize().
  // Sets the fields defined in this class.
  // Does not set fields defined in ancestors.
  void SerializeFields(std::ostream& os, bool &needs_comma) const;

  // Internal functions used by FromJson().
  // Extracts a field from a JSON object.
  static absl::StatusOr<std::vector<std::optional<std::string>>> GetStrings(const nlohmann::json& json);
  static absl::StatusOr<std::vector<std::optional<std::unique_ptr<LiClass1>>>> GetOperations(const nlohmann::json& json);

 private:
  std::vector<std::optional<std::string>> strings_;
  std::vector<std::optional<std::unique_ptr<LiClass1>>> operations_;
};

class LiListOfVariant {
 public:
  explicit LiListOfVariant(
      std::vector<std::variant<bool, std::string>> variants,
      std::vector<std::variant<std::unique_ptr<LiClass1>, std::unique_ptr<LiClass2>>> operations);

  void Serialize(std::ostream& os) const;

  static absl::StatusOr<std::unique_ptr<LiListOfVariant>> FromJson(const nlohmann::json& json);

  std::vector<std::variant<bool, std::string>>* variants();
  const std::vector<std::variant<bool, std::string>>* variants() const;
  void set_variants(std::vector<std::variant<bool, std::string>> variants);

  std::vector<std::variant<std::unique_ptr<LiClass1>, std::unique_ptr<LiClass2>>>* operations();
  const std::vector<std::variant<std::unique_ptr<LiClass1>, std::unique_ptr<LiClass2>>>* operations() const;
  void set_operations(std::vector<std::variant<std::unique_ptr<LiClass1>, std::unique_ptr<LiClass2>>> operations);

 protected:
  // Internal function used by Serialize().
  // Sets the fields defined in this class.
  // Does not set fields defined in ancestors.
  void SerializeFields(std::ostream& os, bool &needs_comma) const;

  // Internal functions used by FromJson().
  // Extracts a field from a JSON object.
  static absl::StatusOr<std::vector<std::variant<bool, std::string>>> GetVariants(const nlohmann::json& json);
  static absl::StatusOr<std::vector<std::variant<std::unique_ptr<LiClass1>, std::unique_ptr<LiClass2>>>> GetOperations(const nlohmann::json& json);

 private:
  std::vector<std::variant<bool, std::string>> variants_;
  std::vector<std::variant<std::unique_ptr<LiClass1>, std::unique_ptr<LiClass2>>> operations_;
};

class LiOptionalListOfOptional {
 public:
  explicit LiOptionalListOfOptional(
      std::optional<std::vector<std::optional<std::string>>> variants);

  void Serialize(std::ostream& os) const;

  static absl::StatusOr<std::unique_ptr<LiOptionalListOfOptional>> FromJson(const nlohmann::json& json);

  std::optional<std::vector<std::optional<std::string>>*> variants();
  std::optional<const std::vector<std::optional<std::string>>*> variants() const;
  void set_variants(std::optional<std::vector<std::optional<std::string>>> variants);

 protected:
  // Internal function used by Serialize().
  // Sets the fields defined in this class.
  // Does not set fields defined in ancestors.
  void SerializeFields(std::ostream& os, bool &needs_comma) const;

  // Internal functions used by FromJson().
  // Extracts a field from a JSON object.
  static absl::StatusOr<std::optional<std::vector<std::optional<std::string>>>> GetVariants(const nlohmann::json& json);

 private:
  std::optional<std::vector<std::optional<std::string>>> variants_;
};

class LiOptionalListOfVariant {
 public:
  explicit LiOptionalListOfVariant(
      std::optional<std::vector<std::variant<bool, std::string>>> variants);

  void Serialize(std::ostream& os) const;

  static absl::StatusOr<std::unique_ptr<LiOptionalListOfVariant>> FromJson(const nlohmann::json& json);

  std::optional<std::vector<std::variant<bool, std::string>>*> variants();
  std::optional<const std::vector<std::variant<bool, std::string>>*> variants() const;
  void set_variants(std::optional<std::vector<std::variant<bool, std::string>>> variants);

 protected:
  // Internal function used by Serialize().
  // Sets the fields defined in this class.
  // Does not set fields defined in ancestors.
  void SerializeFields(std::ostream& os, bool &needs_comma) const;

  // Internal functions used by FromJson().
  // Extracts a field from a JSON object.
  static absl::StatusOr<std::optional<std::vector<std::variant<bool, std::string>>>> GetVariants(const nlohmann::json& json);

 private:
  std::optional<std::vector<std::variant<bool, std::string>>> variants_;
};

class LiListOfOptionalVariant {
 public:
  explicit LiListOfOptionalVariant(
      std::vector<std::optional<std::variant<bool, std::string>>> variants,
      std::vector<std::optional<std::variant<std::unique_ptr<LiClass1>, std::unique_ptr<LiClass2>>>> operations);

  void Serialize(std::ostream& os) const;

  static absl::StatusOr<std::unique_ptr<LiListOfOptionalVariant>> FromJson(const nlohmann::json& json);

  std::vector<std::optional<std::variant<bool, std::string>>>* variants();
  const std::vector<std::optional<std::variant<bool, std::string>>>* variants() const;
  void set_variants(std::vector<std::optional<std::variant<bool, std::string>>> variants);

  std::vector<std::optional<std::variant<std::unique_ptr<LiClass1>, std::unique_ptr<LiClass2>>>>* operations();
  const std::vector<std::optional<std::variant<std::unique_ptr<LiClass1>, std::unique_ptr<LiClass2>>>>* operations() const;
  void set_operations(std::vector<std::optional<std::variant<std::unique_ptr<LiClass1>, std::unique_ptr<LiClass2>>>> operations);

 protected:
  // Internal function used by Serialize().
  // Sets the fields defined in this class.
  // Does not set fields defined in ancestors.
  void SerializeFields(std::ostream& os, bool &needs_comma) const;

  // Internal functions used by FromJson().
  // Extracts a field from a JSON object.
  static absl::StatusOr<std::vector<std::optional<std::variant<bool, std::string>>>> GetVariants(const nlohmann::json& json);
  static absl::StatusOr<std::vector<std::optional<std::variant<std::unique_ptr<LiClass1>, std::unique_ptr<LiClass2>>>>> GetOperations(const nlohmann::json& json);

 private:
  std::vector<std::optional<std::variant<bool, std::string>>> variants_;
  std::vector<std::optional<std::variant<std::unique_ptr<LiClass1>, std::unique_ptr<LiClass2>>>> operations_;
};

class LiOptionalListOfOptionalVariant {
 public:
  explicit LiOptionalListOfOptionalVariant(
      std::optional<std::vector<std::optional<std::variant<bool, std::string>>>> variants);

  void Serialize(std::ostream& os) const;

  static absl::StatusOr<std::unique_ptr<LiOptionalListOfOptionalVariant>> FromJson(const nlohmann::json& json);

  std::optional<std::vector<std::optional<std::variant<bool, std::string>>>*> variants();
  std::optional<const std::vector<std::optional<std::variant<bool, std::string>>>*> variants() const;
  void set_variants(std::optional<std::vector<std::optional<std::variant<bool, std::string>>>> variants);

 protected:
  // Internal function used by Serialize().
  // Sets the fields defined in this class.
  // Does not set fields defined in ancestors.
  void SerializeFields(std::ostream& os, bool &needs_comma) const;

  // Internal functions used by FromJson().
  // Extracts a field from a JSON object.
  static absl::StatusOr<std::optional<std::vector<std::optional<std::variant<bool, std::string>>>>> GetVariants(const nlohmann::json& json);

 private:
  std::optional<std::vector<std::optional<std::variant<bool, std::string>>>> variants_;
};

// clang-format on
// NOLINTEND(whitespace/line_length)
// IWYU pragma: end_keep

}  // namespace maldoca

#endif  // MALDOCA_ASTGEN_TEST_LIST_AST_GENERATED_H_
