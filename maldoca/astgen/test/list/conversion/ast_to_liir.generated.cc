// Copyright 2024 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// =============================================================================
// STOP!! DO NOT MODIFY!! THIS FILE IS AUTOMATICALLY GENERATED.
// =============================================================================

// IWYU pragma: begin_keep
// NOLINTBEGIN(whitespace/line_length)
// clang-format off

#include "maldoca/astgen/test/list/conversion/ast_to_liir.h"

#include <memory>
#include <utility>
#include <vector>

#include "llvm/ADT/APFloat.h"
#include "mlir/IR/Attributes.h"
#include "mlir/IR/Block.h"
#include "mlir/IR/Builders.h"
#include "mlir/IR/BuiltinAttributes.h"
#include "mlir/IR/BuiltinTypes.h"
#include "mlir/IR/Operation.h"
#include "mlir/IR/Region.h"
#include "mlir/IR/Value.h"
#include "absl/cleanup/cleanup.h"
#include "absl/log/check.h"
#include "absl/log/log.h"
#include "absl/types/optional.h"
#include "absl/types/variant.h"
#include "maldoca/astgen/test/list/ast.generated.h"
#include "maldoca/astgen/test/list/ir.h"

namespace maldoca {

LiirClass1Op AstToLiir::VisitClass1(const LiClass1 *node) {
  return CreateExpr<LiirClass1Op>(node);
}

LiirClass2Op AstToLiir::VisitClass2(const LiClass2 *node) {
  return CreateExpr<LiirClass2Op>(node);
}

LiirSimpleListOp AstToLiir::VisitSimpleList(const LiSimpleList *node) {
  std::vector<mlir::Attribute> mlir_strings_data;
  for (const auto &element : *node->strings()) {
    mlir::StringAttr mlir_element = builder_.getStringAttr(element);
    mlir_strings_data.push_back(std::move(mlir_element));
  }
  auto mlir_strings = builder_.getArrayAttr(mlir_strings_data);
  std::vector<mlir::Value> mlir_operations;
  for (const auto &element : *node->operations()) {
    mlir::Value mlir_element = VisitClass1(element.get());
    mlir_operations.push_back(std::move(mlir_element));
  }
  return CreateExpr<LiirSimpleListOp>(node, mlir_strings, mlir_operations);
}

LiirOptionalListOp AstToLiir::VisitOptionalList(const LiOptionalList *node) {
  mlir::ArrayAttr mlir_strings;
  if (node->strings().has_value()) {
    std::vector<mlir::Attribute> mlir_strings_data;
    for (const auto &element : *node->strings().value()) {
      mlir::StringAttr mlir_element = builder_.getStringAttr(element);
      mlir_strings_data.push_back(std::move(mlir_element));
    }
    mlir_strings = builder_.getArrayAttr(mlir_strings_data);
  }
  return CreateExpr<LiirOptionalListOp>(node, mlir_strings);
}

LiirListOfOptionalOp AstToLiir::VisitListOfOptional(const LiListOfOptional *node) {
  std::vector<mlir::Attribute> mlir_strings_data;
  for (const auto &element : *node->strings()) {
    mlir::StringAttr mlir_element;
    if (element.has_value()) {
      mlir_element = builder_.getStringAttr(element.value());
    }
    mlir_strings_data.push_back(std::move(mlir_element));
  }
  auto mlir_strings = builder_.getArrayAttr(mlir_strings_data);
  std::vector<mlir::Value> mlir_operations;
  for (const auto &element : *node->operations()) {
    mlir::Value mlir_element;
    if (element.has_value()) {
      mlir_element = VisitClass1(element.value().get());
    } else {
      mlir_element = CreateExpr<LiirNoneOp>(node);
    }
    mlir_operations.push_back(std::move(mlir_element));
  }
  return CreateExpr<LiirListOfOptionalOp>(node, mlir_strings, mlir_operations);
}

LiirListOfVariantOp AstToLiir::VisitListOfVariant(const LiListOfVariant *node) {
  std::vector<mlir::Attribute> mlir_variants_data;
  for (const auto &element : *node->variants()) {
    mlir::Attribute mlir_element;
    switch (element.index()) {
      case 0: {
        mlir_element = builder_.getBoolAttr(std::get<0>(element));
        break;
      }
      case 1: {
        mlir_element = builder_.getStringAttr(std::get<1>(element));
        break;
      }
      default:
        LOG(FATAL) << "Unreachable code.";
    }
    mlir_variants_data.push_back(std::move(mlir_element));
  }
  auto mlir_variants = builder_.getArrayAttr(mlir_variants_data);
  std::vector<mlir::Value> mlir_operations;
  for (const auto &element : *node->operations()) {
    mlir::Value mlir_element;
    switch (element.index()) {
      case 0: {
        mlir_element = VisitClass1(std::get<0>(element).get());
        break;
      }
      case 1: {
        mlir_element = VisitClass2(std::get<1>(element).get());
        break;
      }
      default:
        LOG(FATAL) << "Unreachable code.";
    }
    mlir_operations.push_back(std::move(mlir_element));
  }
  return CreateExpr<LiirListOfVariantOp>(node, mlir_variants, mlir_operations);
}

LiirOptionalListOfOptionalOp AstToLiir::VisitOptionalListOfOptional(const LiOptionalListOfOptional *node) {
  mlir::ArrayAttr mlir_variants;
  if (node->variants().has_value()) {
    std::vector<mlir::Attribute> mlir_variants_data;
    for (const auto &element : *node->variants().value()) {
      mlir::StringAttr mlir_element;
      if (element.has_value()) {
        mlir_element = builder_.getStringAttr(element.value());
      }
      mlir_variants_data.push_back(std::move(mlir_element));
    }
    mlir_variants = builder_.getArrayAttr(mlir_variants_data);
  }
  return CreateExpr<LiirOptionalListOfOptionalOp>(node, mlir_variants);
}

LiirOptionalListOfVariantOp AstToLiir::VisitOptionalListOfVariant(const LiOptionalListOfVariant *node) {
  mlir::ArrayAttr mlir_variants;
  if (node->variants().has_value()) {
    std::vector<mlir::Attribute> mlir_variants_data;
    for (const auto &element : *node->variants().value()) {
      mlir::Attribute mlir_element;
      switch (element.index()) {
        case 0: {
          mlir_element = builder_.getBoolAttr(std::get<0>(element));
          break;
        }
        case 1: {
          mlir_element = builder_.getStringAttr(std::get<1>(element));
          break;
        }
        default:
          LOG(FATAL) << "Unreachable code.";
      }
      mlir_variants_data.push_back(std::move(mlir_element));
    }
    mlir_variants = builder_.getArrayAttr(mlir_variants_data);
  }
  return CreateExpr<LiirOptionalListOfVariantOp>(node, mlir_variants);
}

LiirListOfOptionalVariantOp AstToLiir::VisitListOfOptionalVariant(const LiListOfOptionalVariant *node) {
  std::vector<mlir::Attribute> mlir_variants_data;
  for (const auto &element : *node->variants()) {
    mlir::Attribute mlir_element;
    if (element.has_value()) {
      switch (element.value().index()) {
        case 0: {
          mlir_element = builder_.getBoolAttr(std::get<0>(element.value()));
          break;
        }
        case 1: {
          mlir_element = builder_.getStringAttr(std::get<1>(element.value()));
          break;
        }
        default:
          LOG(FATAL) << "Unreachable code.";
      }
    }
    mlir_variants_data.push_back(std::move(mlir_element));
  }
  auto mlir_variants = builder_.getArrayAttr(mlir_variants_data);
  std::vector<mlir::Value> mlir_operations;
  for (const auto &element : *node->operations()) {
    mlir::Value mlir_element;
    if (element.has_value()) {
      switch (element.value().index()) {
        case 0: {
          mlir_element = VisitClass1(std::get<0>(element.value()).get());
          break;
        }
        case 1: {
          mlir_element = VisitClass2(std::get<1>(element.value()).get());
          break;
        }
        default:
          LOG(FATAL) << "Unreachable code.";
      }
    } else {
      mlir_element = CreateExpr<LiirNoneOp>(node);
    }
    mlir_operations.push_back(std::move(mlir_element));
  }
  return CreateExpr<LiirListOfOptionalVariantOp>(node, mlir_variants, mlir_operations);
}

LiirOptionalListOfOptionalVariantOp AstToLiir::VisitOptionalListOfOptionalVariant(const LiOptionalListOfOptionalVariant *node) {
  mlir::ArrayAttr mlir_variants;
  if (node->variants().has_value()) {
    std::vector<mlir::Attribute> mlir_variants_data;
    for (const auto &element : *node->variants().value()) {
      mlir::Attribute mlir_element;
      if (element.has_value()) {
        switch (element.value().index()) {
          case 0: {
            mlir_element = builder_.getBoolAttr(std::get<0>(element.value()));
            break;
          }
          case 1: {
            mlir_element = builder_.getStringAttr(std::get<1>(element.value()));
            break;
          }
          default:
            LOG(FATAL) << "Unreachable code.";
        }
      }
      mlir_variants_data.push_back(std::move(mlir_element));
    }
    mlir_variants = builder_.getArrayAttr(mlir_variants_data);
  }
  return CreateExpr<LiirOptionalListOfOptionalVariantOp>(node, mlir_variants);
}

// clang-format on
// NOLINTEND(whitespace/line_length)
// IWYU pragma: end_keep

}  // namespace maldoca
