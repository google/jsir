// Copyright 2024 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// =============================================================================
// STOP!! DO NOT MODIFY!! THIS FILE IS AUTOMATICALLY GENERATED.
// =============================================================================

#include "maldoca/astgen/test/list/ast.generated.h"

// IWYU pragma: begin_keep
// NOLINTBEGIN(whitespace/line_length)
// clang-format off

#include <cstdint>
#include <memory>
#include <optional>
#include <string>
#include <utility>
#include <variant>
#include <vector>

#include "absl/container/flat_hash_map.h"
#include "absl/memory/memory.h"
#include "absl/log/log.h"
#include "absl/status/status.h"
#include "absl/status/statusor.h"
#include "absl/strings/str_cat.h"
#include "absl/strings/string_view.h"
#include "nlohmann/json.hpp"
#include "maldoca/base/status_macros.h"

namespace maldoca {

// =============================================================================
// LiClass1
// =============================================================================

// =============================================================================
// LiClass2
// =============================================================================

// =============================================================================
// LiSimpleList
// =============================================================================

LiSimpleList::LiSimpleList(
    std::vector<std::string> strings,
    std::vector<std::unique_ptr<LiClass1>> operations)
    : strings_(std::move(strings)),
      operations_(std::move(operations)) {}

std::vector<std::string>* LiSimpleList::strings() {
  return &strings_;
}

const std::vector<std::string>* LiSimpleList::strings() const {
  return &strings_;
}

void LiSimpleList::set_strings(std::vector<std::string> strings) {
  strings_ = std::move(strings);
}

std::vector<std::unique_ptr<LiClass1>>* LiSimpleList::operations() {
  return &operations_;
}

const std::vector<std::unique_ptr<LiClass1>>* LiSimpleList::operations() const {
  return &operations_;
}

void LiSimpleList::set_operations(std::vector<std::unique_ptr<LiClass1>> operations) {
  operations_ = std::move(operations);
}

// =============================================================================
// LiOptionalList
// =============================================================================

LiOptionalList::LiOptionalList(
    std::optional<std::vector<std::string>> strings)
    : strings_(std::move(strings)) {}

std::optional<std::vector<std::string>*> LiOptionalList::strings() {
  if (!strings_.has_value()) {
    return std::nullopt;
  } else {
    return &strings_.value();
  }
}

std::optional<const std::vector<std::string>*> LiOptionalList::strings() const {
  if (!strings_.has_value()) {
    return std::nullopt;
  } else {
    return &strings_.value();
  }
}

void LiOptionalList::set_strings(std::optional<std::vector<std::string>> strings) {
  strings_ = std::move(strings);
}

// =============================================================================
// LiListOfOptional
// =============================================================================

LiListOfOptional::LiListOfOptional(
    std::vector<std::optional<std::string>> strings,
    std::vector<std::optional<std::unique_ptr<LiClass1>>> operations)
    : strings_(std::move(strings)),
      operations_(std::move(operations)) {}

std::vector<std::optional<std::string>>* LiListOfOptional::strings() {
  return &strings_;
}

const std::vector<std::optional<std::string>>* LiListOfOptional::strings() const {
  return &strings_;
}

void LiListOfOptional::set_strings(std::vector<std::optional<std::string>> strings) {
  strings_ = std::move(strings);
}

std::vector<std::optional<std::unique_ptr<LiClass1>>>* LiListOfOptional::operations() {
  return &operations_;
}

const std::vector<std::optional<std::unique_ptr<LiClass1>>>* LiListOfOptional::operations() const {
  return &operations_;
}

void LiListOfOptional::set_operations(std::vector<std::optional<std::unique_ptr<LiClass1>>> operations) {
  operations_ = std::move(operations);
}

// =============================================================================
// LiListOfVariant
// =============================================================================

LiListOfVariant::LiListOfVariant(
    std::vector<std::variant<bool, std::string>> variants,
    std::vector<std::variant<std::unique_ptr<LiClass1>, std::unique_ptr<LiClass2>>> operations)
    : variants_(std::move(variants)),
      operations_(std::move(operations)) {}

std::vector<std::variant<bool, std::string>>* LiListOfVariant::variants() {
  return &variants_;
}

const std::vector<std::variant<bool, std::string>>* LiListOfVariant::variants() const {
  return &variants_;
}

void LiListOfVariant::set_variants(std::vector<std::variant<bool, std::string>> variants) {
  variants_ = std::move(variants);
}

std::vector<std::variant<std::unique_ptr<LiClass1>, std::unique_ptr<LiClass2>>>* LiListOfVariant::operations() {
  return &operations_;
}

const std::vector<std::variant<std::unique_ptr<LiClass1>, std::unique_ptr<LiClass2>>>* LiListOfVariant::operations() const {
  return &operations_;
}

void LiListOfVariant::set_operations(std::vector<std::variant<std::unique_ptr<LiClass1>, std::unique_ptr<LiClass2>>> operations) {
  operations_ = std::move(operations);
}

// =============================================================================
// LiOptionalListOfOptional
// =============================================================================

LiOptionalListOfOptional::LiOptionalListOfOptional(
    std::optional<std::vector<std::optional<std::string>>> variants)
    : variants_(std::move(variants)) {}

std::optional<std::vector<std::optional<std::string>>*> LiOptionalListOfOptional::variants() {
  if (!variants_.has_value()) {
    return std::nullopt;
  } else {
    return &variants_.value();
  }
}

std::optional<const std::vector<std::optional<std::string>>*> LiOptionalListOfOptional::variants() const {
  if (!variants_.has_value()) {
    return std::nullopt;
  } else {
    return &variants_.value();
  }
}

void LiOptionalListOfOptional::set_variants(std::optional<std::vector<std::optional<std::string>>> variants) {
  variants_ = std::move(variants);
}

// =============================================================================
// LiOptionalListOfVariant
// =============================================================================

LiOptionalListOfVariant::LiOptionalListOfVariant(
    std::optional<std::vector<std::variant<bool, std::string>>> variants)
    : variants_(std::move(variants)) {}

std::optional<std::vector<std::variant<bool, std::string>>*> LiOptionalListOfVariant::variants() {
  if (!variants_.has_value()) {
    return std::nullopt;
  } else {
    return &variants_.value();
  }
}

std::optional<const std::vector<std::variant<bool, std::string>>*> LiOptionalListOfVariant::variants() const {
  if (!variants_.has_value()) {
    return std::nullopt;
  } else {
    return &variants_.value();
  }
}

void LiOptionalListOfVariant::set_variants(std::optional<std::vector<std::variant<bool, std::string>>> variants) {
  variants_ = std::move(variants);
}

// =============================================================================
// LiListOfOptionalVariant
// =============================================================================

LiListOfOptionalVariant::LiListOfOptionalVariant(
    std::vector<std::optional<std::variant<bool, std::string>>> variants,
    std::vector<std::optional<std::variant<std::unique_ptr<LiClass1>, std::unique_ptr<LiClass2>>>> operations)
    : variants_(std::move(variants)),
      operations_(std::move(operations)) {}

std::vector<std::optional<std::variant<bool, std::string>>>* LiListOfOptionalVariant::variants() {
  return &variants_;
}

const std::vector<std::optional<std::variant<bool, std::string>>>* LiListOfOptionalVariant::variants() const {
  return &variants_;
}

void LiListOfOptionalVariant::set_variants(std::vector<std::optional<std::variant<bool, std::string>>> variants) {
  variants_ = std::move(variants);
}

std::vector<std::optional<std::variant<std::unique_ptr<LiClass1>, std::unique_ptr<LiClass2>>>>* LiListOfOptionalVariant::operations() {
  return &operations_;
}

const std::vector<std::optional<std::variant<std::unique_ptr<LiClass1>, std::unique_ptr<LiClass2>>>>* LiListOfOptionalVariant::operations() const {
  return &operations_;
}

void LiListOfOptionalVariant::set_operations(std::vector<std::optional<std::variant<std::unique_ptr<LiClass1>, std::unique_ptr<LiClass2>>>> operations) {
  operations_ = std::move(operations);
}

// =============================================================================
// LiOptionalListOfOptionalVariant
// =============================================================================

LiOptionalListOfOptionalVariant::LiOptionalListOfOptionalVariant(
    std::optional<std::vector<std::optional<std::variant<bool, std::string>>>> variants)
    : variants_(std::move(variants)) {}

std::optional<std::vector<std::optional<std::variant<bool, std::string>>>*> LiOptionalListOfOptionalVariant::variants() {
  if (!variants_.has_value()) {
    return std::nullopt;
  } else {
    return &variants_.value();
  }
}

std::optional<const std::vector<std::optional<std::variant<bool, std::string>>>*> LiOptionalListOfOptionalVariant::variants() const {
  if (!variants_.has_value()) {
    return std::nullopt;
  } else {
    return &variants_.value();
  }
}

void LiOptionalListOfOptionalVariant::set_variants(std::optional<std::vector<std::optional<std::variant<bool, std::string>>>> variants) {
  variants_ = std::move(variants);
}

// clang-format on
// NOLINTEND(whitespace/line_length)
// IWYU pragma: end_keep

}  // namespace maldoca
