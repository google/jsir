// Copyright 2024 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// =============================================================================
// STOP!! DO NOT MODIFY!! THIS FILE IS AUTOMATICALLY GENERATED.
// =============================================================================

// NOLINTBEGIN(whitespace/line_length)
// clang-format off
// IWYU pragma: begin_keep

#include <cstdint>
#include <memory>
#include <optional>
#include <string>
#include <utility>
#include <variant>
#include <vector>

#include "maldoca/astgen/test/list/ast.generated.h"
#include "absl/container/flat_hash_set.h"
#include "absl/memory/memory.h"
#include "absl/status/status.h"
#include "absl/status/statusor.h"
#include "absl/strings/str_cat.h"
#include "absl/strings/string_view.h"
#include "maldoca/base/status_macros.h"
#include "nlohmann/json.hpp"

namespace maldoca {

// =============================================================================
// LiClass1
// =============================================================================

static bool IsClass1(const nlohmann::json& json) {
  if (!json.is_object()) {
    return false;
  }
  return true;
}

absl::StatusOr<std::unique_ptr<LiClass1>>
LiClass1::FromJson(const nlohmann::json& json) {
  if (!json.is_object()) {
    return absl::InvalidArgumentError("JSON is not an object.");
  }


  return absl::make_unique<LiClass1>(
  );
}

// =============================================================================
// LiClass2
// =============================================================================

static bool IsClass2(const nlohmann::json& json) {
  if (!json.is_object()) {
    return false;
  }
  return true;
}

absl::StatusOr<std::unique_ptr<LiClass2>>
LiClass2::FromJson(const nlohmann::json& json) {
  if (!json.is_object()) {
    return absl::InvalidArgumentError("JSON is not an object.");
  }


  return absl::make_unique<LiClass2>(
  );
}

// =============================================================================
// LiSimpleList
// =============================================================================

absl::StatusOr<std::vector<std::string>>
LiSimpleList::GetStrings(const nlohmann::json& json) {
  auto strings_it = json.find("strings");
  if (strings_it == json.end()) {
    return absl::InvalidArgumentError("`strings` is undefined.");
  }
  const nlohmann::json& json_strings = strings_it.value();

  if (json_strings.is_null()) {
    return absl::InvalidArgumentError("json_strings is null.");
  }
  if (!json_strings.is_array()) {
    return absl::InvalidArgumentError("json_strings expected to be array.");
  }

  std::vector<std::string> strings;
  for (const nlohmann::json& json_strings_element : json_strings) {
    if (json_strings_element.is_null()) {
      return absl::InvalidArgumentError("json_strings_element is null.");
    }
    if (!json_strings_element.is_string()) {
      return absl::InvalidArgumentError("Expecting json_strings_element.is_string().");
    }
    auto strings_element = json_strings_element.get<std::string>();
    strings.push_back(std::move(strings_element));
  }
  return strings;
}

absl::StatusOr<std::vector<std::unique_ptr<LiClass1>>>
LiSimpleList::GetOperations(const nlohmann::json& json) {
  auto operations_it = json.find("operations");
  if (operations_it == json.end()) {
    return absl::InvalidArgumentError("`operations` is undefined.");
  }
  const nlohmann::json& json_operations = operations_it.value();

  if (json_operations.is_null()) {
    return absl::InvalidArgumentError("json_operations is null.");
  }
  if (!json_operations.is_array()) {
    return absl::InvalidArgumentError("json_operations expected to be array.");
  }

  std::vector<std::unique_ptr<LiClass1>> operations;
  for (const nlohmann::json& json_operations_element : json_operations) {
    if (json_operations_element.is_null()) {
      return absl::InvalidArgumentError("json_operations_element is null.");
    }
    MALDOCA_ASSIGN_OR_RETURN(auto operations_element, LiClass1::FromJson(json_operations_element));
    operations.push_back(std::move(operations_element));
  }
  return operations;
}

absl::StatusOr<std::unique_ptr<LiSimpleList>>
LiSimpleList::FromJson(const nlohmann::json& json) {
  if (!json.is_object()) {
    return absl::InvalidArgumentError("JSON is not an object.");
  }

  MALDOCA_ASSIGN_OR_RETURN(auto strings, LiSimpleList::GetStrings(json));
  MALDOCA_ASSIGN_OR_RETURN(auto operations, LiSimpleList::GetOperations(json));

  return absl::make_unique<LiSimpleList>(
      std::move(strings),
      std::move(operations));
}

// =============================================================================
// LiOptionalList
// =============================================================================

absl::StatusOr<std::optional<std::vector<std::string>>>
LiOptionalList::GetStrings(const nlohmann::json& json) {
  auto strings_it = json.find("strings");
  if (strings_it == json.end()) {
    return std::nullopt;
  }
  const nlohmann::json& json_strings = strings_it.value();

  if (json_strings.is_null()) {
    return absl::InvalidArgumentError("json_strings is null.");
  }
  if (!json_strings.is_array()) {
    return absl::InvalidArgumentError("json_strings expected to be array.");
  }

  std::vector<std::string> strings;
  for (const nlohmann::json& json_strings_element : json_strings) {
    if (json_strings_element.is_null()) {
      return absl::InvalidArgumentError("json_strings_element is null.");
    }
    if (!json_strings_element.is_string()) {
      return absl::InvalidArgumentError("Expecting json_strings_element.is_string().");
    }
    auto strings_element = json_strings_element.get<std::string>();
    strings.push_back(std::move(strings_element));
  }
  return strings;
}

absl::StatusOr<std::unique_ptr<LiOptionalList>>
LiOptionalList::FromJson(const nlohmann::json& json) {
  if (!json.is_object()) {
    return absl::InvalidArgumentError("JSON is not an object.");
  }

  MALDOCA_ASSIGN_OR_RETURN(auto strings, LiOptionalList::GetStrings(json));

  return absl::make_unique<LiOptionalList>(
      std::move(strings));
}

// =============================================================================
// LiListOfOptional
// =============================================================================

absl::StatusOr<std::vector<std::optional<std::string>>>
LiListOfOptional::GetStrings(const nlohmann::json& json) {
  auto strings_it = json.find("strings");
  if (strings_it == json.end()) {
    return absl::InvalidArgumentError("`strings` is undefined.");
  }
  const nlohmann::json& json_strings = strings_it.value();

  if (json_strings.is_null()) {
    return absl::InvalidArgumentError("json_strings is null.");
  }
  if (!json_strings.is_array()) {
    return absl::InvalidArgumentError("json_strings expected to be array.");
  }

  std::vector<std::optional<std::string>> strings;
  for (const nlohmann::json& json_strings_element : json_strings) {
    std::optional<std::string> strings_element;
    if (!json_strings_element.is_null()) {
      if (!json_strings_element.is_string()) {
        return absl::InvalidArgumentError("Expecting json_strings_element.is_string().");
      }
      strings_element = json_strings_element.get<std::string>();
    }
    strings.push_back(std::move(strings_element));
  }
  return strings;
}

absl::StatusOr<std::vector<std::optional<std::unique_ptr<LiClass1>>>>
LiListOfOptional::GetOperations(const nlohmann::json& json) {
  auto operations_it = json.find("operations");
  if (operations_it == json.end()) {
    return absl::InvalidArgumentError("`operations` is undefined.");
  }
  const nlohmann::json& json_operations = operations_it.value();

  if (json_operations.is_null()) {
    return absl::InvalidArgumentError("json_operations is null.");
  }
  if (!json_operations.is_array()) {
    return absl::InvalidArgumentError("json_operations expected to be array.");
  }

  std::vector<std::optional<std::unique_ptr<LiClass1>>> operations;
  for (const nlohmann::json& json_operations_element : json_operations) {
    std::optional<std::unique_ptr<LiClass1>> operations_element;
    if (!json_operations_element.is_null()) {
      MALDOCA_ASSIGN_OR_RETURN(operations_element, LiClass1::FromJson(json_operations_element));
    }
    operations.push_back(std::move(operations_element));
  }
  return operations;
}

absl::StatusOr<std::unique_ptr<LiListOfOptional>>
LiListOfOptional::FromJson(const nlohmann::json& json) {
  if (!json.is_object()) {
    return absl::InvalidArgumentError("JSON is not an object.");
  }

  MALDOCA_ASSIGN_OR_RETURN(auto strings, LiListOfOptional::GetStrings(json));
  MALDOCA_ASSIGN_OR_RETURN(auto operations, LiListOfOptional::GetOperations(json));

  return absl::make_unique<LiListOfOptional>(
      std::move(strings),
      std::move(operations));
}

// =============================================================================
// LiListOfVariant
// =============================================================================

absl::StatusOr<std::vector<std::variant<bool, std::string>>>
LiListOfVariant::GetVariants(const nlohmann::json& json) {
  auto variants_it = json.find("variants");
  if (variants_it == json.end()) {
    return absl::InvalidArgumentError("`variants` is undefined.");
  }
  const nlohmann::json& json_variants = variants_it.value();

  if (json_variants.is_null()) {
    return absl::InvalidArgumentError("json_variants is null.");
  }
  if (!json_variants.is_array()) {
    return absl::InvalidArgumentError("json_variants expected to be array.");
  }

  std::vector<std::variant<bool, std::string>> variants;
  for (const nlohmann::json& json_variants_element : json_variants) {
    if (json_variants_element.is_null()) {
      return absl::InvalidArgumentError("json_variants_element is null.");
    }
    std::variant<bool, std::string> variants_element;
    if (json_variants_element.is_boolean()) {
      variants_element = json_variants_element.get<bool>();
    } else if (json_variants_element.is_string()) {
      variants_element = json_variants_element.get<std::string>();
    } else {
      auto result = absl::InvalidArgumentError("json_variants_element has invalid type.");
      result.SetPayload("json", absl::Cord{json.dump()});
      result.SetPayload("json_element", absl::Cord{json_variants_element.dump()});
      return result;
    }
    variants.push_back(std::move(variants_element));
  }
  return variants;
}

absl::StatusOr<std::vector<std::variant<std::unique_ptr<LiClass1>, std::unique_ptr<LiClass2>>>>
LiListOfVariant::GetOperations(const nlohmann::json& json) {
  auto operations_it = json.find("operations");
  if (operations_it == json.end()) {
    return absl::InvalidArgumentError("`operations` is undefined.");
  }
  const nlohmann::json& json_operations = operations_it.value();

  if (json_operations.is_null()) {
    return absl::InvalidArgumentError("json_operations is null.");
  }
  if (!json_operations.is_array()) {
    return absl::InvalidArgumentError("json_operations expected to be array.");
  }

  std::vector<std::variant<std::unique_ptr<LiClass1>, std::unique_ptr<LiClass2>>> operations;
  for (const nlohmann::json& json_operations_element : json_operations) {
    if (json_operations_element.is_null()) {
      return absl::InvalidArgumentError("json_operations_element is null.");
    }
    std::variant<std::unique_ptr<LiClass1>, std::unique_ptr<LiClass2>> operations_element;
    if (IsClass1(json_operations_element)) {
      MALDOCA_ASSIGN_OR_RETURN(operations_element, LiClass1::FromJson(json_operations_element));
    } else if (IsClass2(json_operations_element)) {
      MALDOCA_ASSIGN_OR_RETURN(operations_element, LiClass2::FromJson(json_operations_element));
    } else {
      auto result = absl::InvalidArgumentError("json_operations_element has invalid type.");
      result.SetPayload("json", absl::Cord{json.dump()});
      result.SetPayload("json_element", absl::Cord{json_operations_element.dump()});
      return result;
    }
    operations.push_back(std::move(operations_element));
  }
  return operations;
}

absl::StatusOr<std::unique_ptr<LiListOfVariant>>
LiListOfVariant::FromJson(const nlohmann::json& json) {
  if (!json.is_object()) {
    return absl::InvalidArgumentError("JSON is not an object.");
  }

  MALDOCA_ASSIGN_OR_RETURN(auto variants, LiListOfVariant::GetVariants(json));
  MALDOCA_ASSIGN_OR_RETURN(auto operations, LiListOfVariant::GetOperations(json));

  return absl::make_unique<LiListOfVariant>(
      std::move(variants),
      std::move(operations));
}

// =============================================================================
// LiOptionalListOfOptional
// =============================================================================

absl::StatusOr<std::optional<std::vector<std::optional<std::string>>>>
LiOptionalListOfOptional::GetVariants(const nlohmann::json& json) {
  auto variants_it = json.find("variants");
  if (variants_it == json.end()) {
    return std::nullopt;
  }
  const nlohmann::json& json_variants = variants_it.value();

  if (json_variants.is_null()) {
    return absl::InvalidArgumentError("json_variants is null.");
  }
  if (!json_variants.is_array()) {
    return absl::InvalidArgumentError("json_variants expected to be array.");
  }

  std::vector<std::optional<std::string>> variants;
  for (const nlohmann::json& json_variants_element : json_variants) {
    std::optional<std::string> variants_element;
    if (!json_variants_element.is_null()) {
      if (!json_variants_element.is_string()) {
        return absl::InvalidArgumentError("Expecting json_variants_element.is_string().");
      }
      variants_element = json_variants_element.get<std::string>();
    }
    variants.push_back(std::move(variants_element));
  }
  return variants;
}

absl::StatusOr<std::unique_ptr<LiOptionalListOfOptional>>
LiOptionalListOfOptional::FromJson(const nlohmann::json& json) {
  if (!json.is_object()) {
    return absl::InvalidArgumentError("JSON is not an object.");
  }

  MALDOCA_ASSIGN_OR_RETURN(auto variants, LiOptionalListOfOptional::GetVariants(json));

  return absl::make_unique<LiOptionalListOfOptional>(
      std::move(variants));
}

// =============================================================================
// LiOptionalListOfVariant
// =============================================================================

absl::StatusOr<std::optional<std::vector<std::variant<bool, std::string>>>>
LiOptionalListOfVariant::GetVariants(const nlohmann::json& json) {
  auto variants_it = json.find("variants");
  if (variants_it == json.end()) {
    return std::nullopt;
  }
  const nlohmann::json& json_variants = variants_it.value();

  if (json_variants.is_null()) {
    return absl::InvalidArgumentError("json_variants is null.");
  }
  if (!json_variants.is_array()) {
    return absl::InvalidArgumentError("json_variants expected to be array.");
  }

  std::vector<std::variant<bool, std::string>> variants;
  for (const nlohmann::json& json_variants_element : json_variants) {
    if (json_variants_element.is_null()) {
      return absl::InvalidArgumentError("json_variants_element is null.");
    }
    std::variant<bool, std::string> variants_element;
    if (json_variants_element.is_boolean()) {
      variants_element = json_variants_element.get<bool>();
    } else if (json_variants_element.is_string()) {
      variants_element = json_variants_element.get<std::string>();
    } else {
      auto result = absl::InvalidArgumentError("json_variants_element has invalid type.");
      result.SetPayload("json", absl::Cord{json.dump()});
      result.SetPayload("json_element", absl::Cord{json_variants_element.dump()});
      return result;
    }
    variants.push_back(std::move(variants_element));
  }
  return variants;
}

absl::StatusOr<std::unique_ptr<LiOptionalListOfVariant>>
LiOptionalListOfVariant::FromJson(const nlohmann::json& json) {
  if (!json.is_object()) {
    return absl::InvalidArgumentError("JSON is not an object.");
  }

  MALDOCA_ASSIGN_OR_RETURN(auto variants, LiOptionalListOfVariant::GetVariants(json));

  return absl::make_unique<LiOptionalListOfVariant>(
      std::move(variants));
}

// =============================================================================
// LiListOfOptionalVariant
// =============================================================================

absl::StatusOr<std::vector<std::optional<std::variant<bool, std::string>>>>
LiListOfOptionalVariant::GetVariants(const nlohmann::json& json) {
  auto variants_it = json.find("variants");
  if (variants_it == json.end()) {
    return absl::InvalidArgumentError("`variants` is undefined.");
  }
  const nlohmann::json& json_variants = variants_it.value();

  if (json_variants.is_null()) {
    return absl::InvalidArgumentError("json_variants is null.");
  }
  if (!json_variants.is_array()) {
    return absl::InvalidArgumentError("json_variants expected to be array.");
  }

  std::vector<std::optional<std::variant<bool, std::string>>> variants;
  for (const nlohmann::json& json_variants_element : json_variants) {
    std::optional<std::variant<bool, std::string>> variants_element;
    if (!json_variants_element.is_null()) {
      if (json_variants_element.is_boolean()) {
        variants_element = json_variants_element.get<bool>();
      } else if (json_variants_element.is_string()) {
        variants_element = json_variants_element.get<std::string>();
      } else {
        auto result = absl::InvalidArgumentError("json_variants_element has invalid type.");
        result.SetPayload("json", absl::Cord{json.dump()});
        result.SetPayload("json_element", absl::Cord{json_variants_element.dump()});
        return result;
      }
    }
    variants.push_back(std::move(variants_element));
  }
  return variants;
}

absl::StatusOr<std::vector<std::optional<std::variant<std::unique_ptr<LiClass1>, std::unique_ptr<LiClass2>>>>>
LiListOfOptionalVariant::GetOperations(const nlohmann::json& json) {
  auto operations_it = json.find("operations");
  if (operations_it == json.end()) {
    return absl::InvalidArgumentError("`operations` is undefined.");
  }
  const nlohmann::json& json_operations = operations_it.value();

  if (json_operations.is_null()) {
    return absl::InvalidArgumentError("json_operations is null.");
  }
  if (!json_operations.is_array()) {
    return absl::InvalidArgumentError("json_operations expected to be array.");
  }

  std::vector<std::optional<std::variant<std::unique_ptr<LiClass1>, std::unique_ptr<LiClass2>>>> operations;
  for (const nlohmann::json& json_operations_element : json_operations) {
    std::optional<std::variant<std::unique_ptr<LiClass1>, std::unique_ptr<LiClass2>>> operations_element;
    if (!json_operations_element.is_null()) {
      if (IsClass1(json_operations_element)) {
        MALDOCA_ASSIGN_OR_RETURN(operations_element, LiClass1::FromJson(json_operations_element));
      } else if (IsClass2(json_operations_element)) {
        MALDOCA_ASSIGN_OR_RETURN(operations_element, LiClass2::FromJson(json_operations_element));
      } else {
        auto result = absl::InvalidArgumentError("json_operations_element has invalid type.");
        result.SetPayload("json", absl::Cord{json.dump()});
        result.SetPayload("json_element", absl::Cord{json_operations_element.dump()});
        return result;
      }
    }
    operations.push_back(std::move(operations_element));
  }
  return operations;
}

absl::StatusOr<std::unique_ptr<LiListOfOptionalVariant>>
LiListOfOptionalVariant::FromJson(const nlohmann::json& json) {
  if (!json.is_object()) {
    return absl::InvalidArgumentError("JSON is not an object.");
  }

  MALDOCA_ASSIGN_OR_RETURN(auto variants, LiListOfOptionalVariant::GetVariants(json));
  MALDOCA_ASSIGN_OR_RETURN(auto operations, LiListOfOptionalVariant::GetOperations(json));

  return absl::make_unique<LiListOfOptionalVariant>(
      std::move(variants),
      std::move(operations));
}

// =============================================================================
// LiOptionalListOfOptionalVariant
// =============================================================================

absl::StatusOr<std::optional<std::vector<std::optional<std::variant<bool, std::string>>>>>
LiOptionalListOfOptionalVariant::GetVariants(const nlohmann::json& json) {
  auto variants_it = json.find("variants");
  if (variants_it == json.end()) {
    return std::nullopt;
  }
  const nlohmann::json& json_variants = variants_it.value();

  if (json_variants.is_null()) {
    return absl::InvalidArgumentError("json_variants is null.");
  }
  if (!json_variants.is_array()) {
    return absl::InvalidArgumentError("json_variants expected to be array.");
  }

  std::vector<std::optional<std::variant<bool, std::string>>> variants;
  for (const nlohmann::json& json_variants_element : json_variants) {
    std::optional<std::variant<bool, std::string>> variants_element;
    if (!json_variants_element.is_null()) {
      if (json_variants_element.is_boolean()) {
        variants_element = json_variants_element.get<bool>();
      } else if (json_variants_element.is_string()) {
        variants_element = json_variants_element.get<std::string>();
      } else {
        auto result = absl::InvalidArgumentError("json_variants_element has invalid type.");
        result.SetPayload("json", absl::Cord{json.dump()});
        result.SetPayload("json_element", absl::Cord{json_variants_element.dump()});
        return result;
      }
    }
    variants.push_back(std::move(variants_element));
  }
  return variants;
}

absl::StatusOr<std::unique_ptr<LiOptionalListOfOptionalVariant>>
LiOptionalListOfOptionalVariant::FromJson(const nlohmann::json& json) {
  if (!json.is_object()) {
    return absl::InvalidArgumentError("JSON is not an object.");
  }

  MALDOCA_ASSIGN_OR_RETURN(auto variants, LiOptionalListOfOptionalVariant::GetVariants(json));

  return absl::make_unique<LiOptionalListOfOptionalVariant>(
      std::move(variants));
}

// clang-format on
// NOLINTEND(whitespace/line_length)
// IWYU pragma: end_keep

}  // namespace maldoca
