// Copyright 2024 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// =============================================================================
// STOP!! DO NOT MODIFY!! THIS FILE IS AUTOMATICALLY GENERATED.
// =============================================================================

#ifndef MALDOCA_JS_IR_JSIR_OPS_GENERATED_TD_
#define MALDOCA_JS_IR_JSIR_OPS_GENERATED_TD_

include "mlir/IR/OpBase.td"
include "mlir/IR/SymbolInterfaces.td"
include "mlir/Interfaces/ControlFlowInterfaces.td"
include "mlir/Interfaces/InferTypeOpInterface.td"
include "mlir/Interfaces/LoopLikeInterface.td"
include "mlir/Interfaces/SideEffectInterfaces.td"
include "maldoca/js/ir/interfaces.td"
include "maldoca/js/ir/jsir_dialect.td"
include "maldoca/js/ir/jsir_types.td"

// jsir.*_region_end: An artificial op at the end of a region to collect
// expression-related values.
//
// Take jsir.exprs_region_end as example:
// ======================================
//
// Consider the following function declaration:
// ```
// function foo(arg1, arg2 = defaultValue) {
//   ...
// }
// ```
//
// We lower it to the following IR (simplified):
// ```
// %0 = jsir.identifier_ref {"foo"}
// jsir.function_declaration(%0) (
//   // params
//   {
//     %1 = jsir.identifier_ref {"a"}
//     %2 = jsir.identifier_ref {"b"}
//     %3 = jsir.identifier {"defaultValue"}
//     %4 = jsir.assignment_pattern_ref(%2, %3)
//     jsir.exprs_region_end(%1, %4)
//   },
//   // body
//   {
//     ...
//   }
// )
// ```
//
// We can see that:
//
// 1. We put the parameter-related ops in a region, instead of taking them as
//    normal arguments. In other words, we don't do this:
//
//    ```
//    %0 = jsir.identifier_ref {"foo"}
//    %1 = jsir.identifier_ref {"a"}
//    %2 = jsir.identifier_ref {"b"}
//    %3 = jsir.identifier {"defaultValue"}
//    %4 = jsir.assignment_pattern_ref(%2, %3)
//    jsir.function_declaration(%0, [%1, %4]) (
//      // body
//      {
//        ...
//      }
//    )
//    ```
//
//    The reason is that sometimes an argument might have a default value, and
//    the evaluation of that default value happens once for each function call
//    (i.e. it happens "within" the function). If we take the parameter as
//    normal argument, then %3 is only evaluated once - at function definition
//    time.
//
// 2. Even though the function has two parameters, we use 4 ops to represent
//    them. This is because some parameters are more complex and require more
//    than one op.
//
// 3. We use "jsir.exprs_region_end" to list the "top-level" ops for the
//    parameters. In the example above, ops [%2, %3, %4] all represent the
//    parameter "b = defaultValue", but %4 is the top-level one. In other words,
//    %4 is the root of the tree [%2, %3, %4].
//
// 4. Strictly speaking, we don't really need "jsir.exprs_region_end". The ops
//    within the "params" region form several trees, and we can figure out what
//    the roots are (a root is an op whose return value is not used by any other
//    op). So the use of "jsir.exprs_region_end" is mostly for convenience.
def JsirExprRegionEndOp : Jsir_Op<"expr_region_end", [Terminator]> {
  let arguments = (ins
    AnyType: $argument
  );
}

def JsirExprsRegionEndOp : Jsir_Op<"exprs_region_end", [Terminator]> {
  let arguments = (ins
    Variadic<AnyType>: $arguments
  );
}

def JsirDirectiveLiteralOp : Jsir_Op<
    "directive_literal", [
        Pure
    ]> {
  let arguments = (ins
    StrAttr: $value,
    OptionalAttr<JsirDirectiveLiteralExtraAttr>: $extra
  );

  let results = (outs
    JsirAnyType
  );
}

def JsirDirectiveOp : Jsir_Op<"directive", []> {
  let arguments = (ins
    AnyType: $value
  );
}

def JsirProgramOp : Jsir_Op<
    "program", [
        NoTerminator
    ]> {
  let arguments = (ins
    OptionalAttr<JsirInterpreterDirectiveAttr>: $interpreter,
    StrAttr: $source_type
  );

  let regions = (region
    StmtsRegion: $body,
    StmtsRegion: $directives
  );
}

def JsirFileOp : Jsir_Op<
    "file", [
        NoTerminator,
        IsolatedFromAbove
    ]> {
  let arguments = (ins
    OptionalAttr<TypedArrayAttrBase<JsirCommentAttrInterface, "">>: $comments
  );

  let regions = (region
    StmtRegion: $program
  );
}

def JsirIdentifierOp : Jsir_Op<
    "identifier", [
        JsirExpressionOpInterfaceTraits,
        Pure
    ]> {
  let arguments = (ins
    StrAttr: $name
  );

  let results = (outs
    JsirAnyType
  );
}

def JsirIdentifierRefOp : Jsir_Op<
    "identifier_ref", [
        JsirPatternRefOpInterfaceTraits,
        JsirLValRefOpInterfaceTraits,
        Pure
    ]> {
  let arguments = (ins
    StrAttr: $name
  );

  let results = (outs
    JsirAnyType
  );
}

def JsirPrivateNameOp : Jsir_Op<"private_name", []> {
  let arguments = (ins
    JsirIdentifierAttr: $id
  );

  let results = (outs
    JsirAnyType
  );
}

def JsirRegExpLiteralOp : Jsir_Op<
    "reg_exp_literal", [
        JsirLiteralOpInterfaceTraits,
        Pure
    ]> {
  let hasFolder = 1;

  let arguments = (ins
    StrAttr: $pattern,
    StrAttr: $flags,
    OptionalAttr<JsirRegExpLiteralExtraAttr>: $extra
  );

  let results = (outs
    JsirAnyType
  );
}

def JsirNullLiteralOp : Jsir_Op<
    "null_literal", [
        JsirLiteralOpInterfaceTraits,
        Pure
    ]> {
  let hasFolder = 1;

  let results = (outs
    JsirAnyType
  );
}

def JsirStringLiteralOp : Jsir_Op<
    "string_literal", [
        JsirLiteralOpInterfaceTraits,
        Pure
    ]> {
  let hasFolder = 1;

  let arguments = (ins
    StrAttr: $value,
    OptionalAttr<JsirStringLiteralExtraAttr>: $extra
  );

  let results = (outs
    JsirAnyType
  );
}

def JsirBooleanLiteralOp : Jsir_Op<
    "boolean_literal", [
        JsirLiteralOpInterfaceTraits,
        Pure
    ]> {
  let hasFolder = 1;

  let arguments = (ins
    BoolAttr: $value
  );

  let results = (outs
    JsirAnyType
  );
}

def JsirNumericLiteralOp : Jsir_Op<
    "numeric_literal", [
        JsirLiteralOpInterfaceTraits,
        Pure
    ]> {
  let hasFolder = 1;

  let arguments = (ins
    F64Attr: $value,
    OptionalAttr<JsirNumericLiteralExtraAttr>: $extra
  );

  let results = (outs
    JsirAnyType
  );
}

def JsirBigIntLiteralOp : Jsir_Op<
    "big_int_literal", [
        JsirLiteralOpInterfaceTraits,
        Pure
    ]> {
  let hasFolder = 1;

  let arguments = (ins
    StrAttr: $value,
    OptionalAttr<JsirBigIntLiteralExtraAttr>: $extra
  );

  let results = (outs
    JsirAnyType
  );
}

def JshirBlockStatementOp : Jshir_Op<
    "block_statement", [
        JsirStatementOpInterfaceTraits,
        NoTerminator
    ]> {
  let regions = (region
    StmtsRegion: $body,
    StmtsRegion: $directives
  );
}

def JsirExpressionStatementOp : Jsir_Op<
    "expression_statement", [
        JsirStatementOpInterfaceTraits
    ]> {
  let arguments = (ins
    AnyType: $expression
  );
}

def JsirEmptyStatementOp : Jsir_Op<
    "empty_statement", [
        JsirStatementOpInterfaceTraits
    ]> {
}

def JsirDebuggerStatementOp : Jsir_Op<
    "debugger_statement", [
        JsirStatementOpInterfaceTraits
    ]> {
}

def JshirWithStatementOp : Jshir_Op<
    "with_statement", [
        JsirStatementOpInterfaceTraits,
        NoTerminator
    ]> {
  let arguments = (ins
    AnyType: $object
  );

  let regions = (region
    StmtRegion: $body
  );
}

def JsirReturnStatementOp : Jsir_Op<
    "return_statement", [
        JsirStatementOpInterfaceTraits
    ]> {
  let arguments = (ins
    Optional<AnyType>: $argument
  );
}

def JshirLabeledStatementOp : Jshir_Op<
    "labeled_statement", [
        JsirStatementOpInterfaceTraits,
        NoTerminator
    ]> {
  let arguments = (ins
    JsirIdentifierAttr: $label
  );

  let regions = (region
    StmtRegion: $body
  );
}

def JshirIfStatementOp : Jshir_Op<
    "if_statement", [
        JsirStatementOpInterfaceTraits,
        NoTerminator
    ]> {
  let arguments = (ins
    AnyType: $test
  );

  let regions = (region
    StmtRegion: $consequent,
    OptionalRegion<StmtRegion>: $alternate
  );
}

def JshirSwitchCaseOp : Jshir_Op<
    "switch_case", [
        NoTerminator
    ]> {
  let regions = (region
    OptionalRegion<ExprRegion>: $test,
    StmtsRegion: $consequent
  );
}

def JshirSwitchStatementOp : Jshir_Op<
    "switch_statement", [
        JsirStatementOpInterfaceTraits,
        NoTerminator
    ]> {
  let arguments = (ins
    AnyType: $discriminant
  );

  let regions = (region
    StmtsRegion: $cases
  );
}

def JsirThrowStatementOp : Jsir_Op<
    "throw_statement", [
        JsirStatementOpInterfaceTraits
    ]> {
  let arguments = (ins
    AnyType: $argument
  );
}

def JshirCatchClauseOp : Jshir_Op<
    "catch_clause", [
        NoTerminator
    ]> {
  let arguments = (ins
    Optional<AnyType>: $param
  );

  let regions = (region
    StmtRegion: $body
  );
}

def JshirTryStatementOp : Jshir_Op<
    "try_statement", [
        JsirStatementOpInterfaceTraits,
        NoTerminator
    ]> {
  let regions = (region
    StmtRegion: $block,
    OptionalRegion<StmtRegion>: $handler,
    OptionalRegion<StmtRegion>: $finalizer
  );
}

def JshirWhileStatementOp : Jshir_Op<
    "while_statement", [
        JsirStatementOpInterfaceTraits,
        NoTerminator
    ]> {
  let regions = (region
    ExprRegion: $test,
    StmtRegion: $body
  );
}

def JshirDoWhileStatementOp : Jshir_Op<
    "do_while_statement", [
        JsirStatementOpInterfaceTraits,
        NoTerminator
    ]> {
  let regions = (region
    StmtRegion: $body,
    ExprRegion: $test
  );
}

def JsirVariableDeclaratorOp : Jsir_Op<"variable_declarator", []> {
  let arguments = (ins
    AnyType: $id,
    Optional<AnyType>: $init
  );

  let results = (outs
    JsirAnyType
  );
}

def JsirVariableDeclarationOp : Jsir_Op<
    "variable_declaration", [
        JsirDeclarationOpInterfaceTraits,
        NoTerminator
    ]> {
  let arguments = (ins
    StrAttr: $kind
  );

  let regions = (region
    ExprsRegion: $declarations
  );
}

def JsirFunctionDeclarationOp : Jsir_Op<
    "function_declaration", [
        JsirDeclarationOpInterfaceTraits,
        NoTerminator
    ]> {
  let arguments = (ins
    OptionalAttr<JsirIdentifierAttr>: $id,
    BoolAttr: $generator,
    BoolAttr: $async
  );

  let regions = (region
    ExprsRegion: $params,
    StmtRegion: $body
  );
}

def JsirSuperOp : Jsir_Op<
    "super", [
        Pure
    ]> {
  let results = (outs
    JsirAnyType
  );
}

def JsirImportOp : Jsir_Op<"import", []> {
  let results = (outs
    JsirAnyType
  );
}

def JsirThisExpressionOp : Jsir_Op<
    "this_expression", [
        JsirExpressionOpInterfaceTraits,
        Pure
    ]> {
  let results = (outs
    JsirAnyType
  );
}

def JsirYieldExpressionOp : Jsir_Op<
    "yield_expression", [
        JsirExpressionOpInterfaceTraits
    ]> {
  let arguments = (ins
    Optional<AnyType>: $argument,
    BoolAttr: $delegate
  );

  let results = (outs
    JsirAnyType
  );
}

def JsirAwaitExpressionOp : Jsir_Op<
    "await_expression", [
        JsirExpressionOpInterfaceTraits
    ]> {
  let arguments = (ins
    Optional<AnyType>: $argument
  );

  let results = (outs
    JsirAnyType
  );
}

def JsirSpreadElementOp : Jsir_Op<
    "spread_element", [
        Pure
    ]> {
  let arguments = (ins
    AnyType: $argument
  );

  let results = (outs
    JsirAnyType
  );
}

def JsirArrayExpressionOp : Jsir_Op<
    "array_expression", [
        JsirExpressionOpInterfaceTraits,
        Pure
    ]> {
  let arguments = (ins
    Variadic<AnyType>: $elements
  );

  let results = (outs
    JsirAnyType
  );
}

def JsirFunctionExpressionOp : Jsir_Op<
    "function_expression", [
        JsirExpressionOpInterfaceTraits,
        NoTerminator
    ]> {
  let arguments = (ins
    OptionalAttr<JsirIdentifierAttr>: $id,
    BoolAttr: $generator,
    BoolAttr: $async
  );

  let regions = (region
    ExprsRegion: $params,
    StmtRegion: $body
  );

  let results = (outs
    JsirAnyType
  );
}

def JsirUnaryExpressionOp : Jsir_Op<
    "unary_expression", [
        JsirExpressionOpInterfaceTraits
    ]> {
  let hasFolder = 1;

  let arguments = (ins
    StrAttr: $operator_,
    BoolAttr: $prefix,
    AnyType: $argument
  );

  let results = (outs
    JsirAnyType
  );
}

def JsirUpdateExpressionOp : Jsir_Op<
    "update_expression", [
        JsirExpressionOpInterfaceTraits
    ]> {
  let arguments = (ins
    StrAttr: $operator_,
    AnyType: $argument,
    BoolAttr: $prefix
  );

  let results = (outs
    JsirAnyType
  );
}

def JsirBinaryExpressionOp : Jsir_Op<
    "binary_expression", [
        JsirExpressionOpInterfaceTraits,
        Pure
    ]> {
  let hasFolder = 1;

  let arguments = (ins
    StrAttr: $operator_,
    AnyType: $left,
    AnyType: $right
  );

  let results = (outs
    JsirAnyType
  );
}

def JsirAssignmentExpressionOp : Jsir_Op<
    "assignment_expression", [
        JsirExpressionOpInterfaceTraits
    ]> {
  let arguments = (ins
    StrAttr: $operator_,
    AnyType: $left,
    AnyType: $right
  );

  let results = (outs
    JsirAnyType
  );
}

def JshirLogicalExpressionOp : Jshir_Op<
    "logical_expression", [
        JsirExpressionOpInterfaceTraits,
        NoTerminator,
        Pure
    ]> {
  let arguments = (ins
    StrAttr: $operator_,
    AnyType: $left
  );

  let regions = (region
    ExprRegion: $right
  );

  let results = (outs
    JsirAnyType
  );
}

def JshirConditionalExpressionOp : Jshir_Op<
    "conditional_expression", [
        JsirExpressionOpInterfaceTraits,
        NoTerminator
    ]> {
  let arguments = (ins
    AnyType: $test
  );

  let regions = (region
    ExprRegion: $alternate,
    ExprRegion: $consequent
  );

  let results = (outs
    JsirAnyType
  );
}

def JsirCallExpressionOp : Jsir_Op<
    "call_expression", [
        JsirExpressionOpInterfaceTraits
    ]> {
  let arguments = (ins
    AnyType: $callee,
    Variadic<AnyType>: $arguments
  );

  let results = (outs
    JsirAnyType
  );
}

def JsirOptionalCallExpressionOp : Jsir_Op<
    "optional_call_expression", [
        JsirExpressionOpInterfaceTraits
    ]> {
  let arguments = (ins
    AnyType: $callee,
    Variadic<AnyType>: $arguments,
    BoolAttr: $optional
  );

  let results = (outs
    JsirAnyType
  );
}

def JsirNewExpressionOp : Jsir_Op<
    "new_expression", [
        JsirExpressionOpInterfaceTraits
    ]> {
  let arguments = (ins
    AnyType: $callee,
    Variadic<AnyType>: $arguments
  );

  let results = (outs
    JsirAnyType
  );
}

def JsirSequenceExpressionOp : Jsir_Op<
    "sequence_expression", [
        JsirExpressionOpInterfaceTraits,
        Pure
    ]> {
  let arguments = (ins
    Variadic<AnyType>: $expressions
  );

  let results = (outs
    JsirAnyType
  );
}

def JsirTemplateElementValueOp : Jsir_Op<"template_element_value", []> {
  let arguments = (ins
    OptionalAttr<StrAttr>: $cooked,
    StrAttr: $raw
  );

  let results = (outs
    JsirAnyType
  );
}

def JsirTemplateElementOp : Jsir_Op<
    "template_element", [
        Pure
    ]> {
  let arguments = (ins
    BoolAttr: $tail,
    AnyType: $value
  );

  let results = (outs
    JsirAnyType
  );
}

def JsirTemplateLiteralOp : Jsir_Op<
    "template_literal", [
        JsirExpressionOpInterfaceTraits,
        AttrSizedOperandSegments,
        Pure
    ]> {
  let arguments = (ins
    Variadic<AnyType>: $quasis,
    Variadic<AnyType>: $expressions
  );

  let results = (outs
    JsirAnyType
  );
}

def JsirTaggedTemplateExpressionOp : Jsir_Op<
    "tagged_template_expression", [
        JsirExpressionOpInterfaceTraits,
        Pure
    ]> {
  let arguments = (ins
    AnyType: $tag,
    AnyType: $quasi
  );

  let results = (outs
    JsirAnyType
  );
}

def JsirRestElementRefOp : Jsir_Op<
    "rest_element_ref", [
        JsirPatternRefOpInterfaceTraits,
        JsirLValRefOpInterfaceTraits,
        Pure
    ]> {
  let arguments = (ins
    AnyType: $argument
  );

  let results = (outs
    JsirAnyType
  );
}

def JsirObjectPatternRefOp : Jsir_Op<
    "object_pattern_ref", [
        JsirPatternRefOpInterfaceTraits,
        JsirLValRefOpInterfaceTraits,
        NoTerminator,
        Pure
    ]> {
  let regions = (region
    ExprsRegion: $properties_
  );

  let results = (outs
    JsirAnyType
  );
}

def JsirArrayPatternRefOp : Jsir_Op<
    "array_pattern_ref", [
        JsirPatternRefOpInterfaceTraits,
        JsirLValRefOpInterfaceTraits,
        Pure
    ]> {
  let arguments = (ins
    Variadic<AnyType>: $elements
  );

  let results = (outs
    JsirAnyType
  );
}

def JsirAssignmentPatternRefOp : Jsir_Op<
    "assignment_pattern_ref", [
        JsirPatternRefOpInterfaceTraits,
        JsirLValRefOpInterfaceTraits,
        Pure
    ]> {
  let arguments = (ins
    AnyType: $left,
    AnyType: $right
  );

  let results = (outs
    JsirAnyType
  );
}

def JsirClassPrivatePropertyOp : Jsir_Op<
    "class_private_property", [
        NoTerminator
    ]> {
  let arguments = (ins
    JsirPrivateNameAttr: $key,
    BoolAttr: $static_
  );

  let regions = (region
    OptionalRegion<ExprRegion>: $value
  );
}

def JsirClassBodyOp : Jsir_Op<
    "class_body", [
        NoTerminator
    ]> {
  let regions = (region
    StmtsRegion: $body
  );
}

def JsirClassDeclarationOp : Jsir_Op<
    "class_declaration", [
        JsirDeclarationOpInterfaceTraits,
        NoTerminator
    ]> {
  let arguments = (ins
    Optional<AnyType>: $super_class,
    OptionalAttr<JsirIdentifierAttr>: $id
  );

  let regions = (region
    StmtRegion: $body
  );
}

def JsirClassExpressionOp : Jsir_Op<
    "class_expression", [
        JsirExpressionOpInterfaceTraits,
        NoTerminator
    ]> {
  let arguments = (ins
    Optional<AnyType>: $super_class,
    OptionalAttr<JsirIdentifierAttr>: $id
  );

  let regions = (region
    StmtRegion: $body
  );

  let results = (outs
    JsirAnyType
  );
}

def JsirMetaPropertyOp : Jsir_Op<
    "meta_property", [
        JsirExpressionOpInterfaceTraits
    ]> {
  let arguments = (ins
    JsirIdentifierAttr: $meta,
    JsirIdentifierAttr: $property
  );

  let results = (outs
    JsirAnyType
  );
}

def JsirImportDeclarationOp : Jsir_Op<
    "import_declaration", [
        JsirModuleDeclarationOpInterfaceTraits
    ]> {
  let arguments = (ins
    TypedArrayAttrBase<AnyAttrOf<[JsirImportSpecifierAttr, JsirImportDefaultSpecifierAttr, JsirImportNamespaceSpecifierAttr]>, "">: $specifiers,
    JsirStringLiteralAttr: $source,
    OptionalAttr<JsirImportAttributeAttr>: $assertions
  );
}

def JsirExportNamedDeclarationOp : Jsir_Op<
    "export_named_declaration", [
        JsirModuleDeclarationOpInterfaceTraits,
        NoTerminator
    ]> {
  let arguments = (ins
    TypedArrayAttrBase<JsirExportSpecifierAttr, "">: $specifiers,
    OptionalAttr<JsirStringLiteralAttr>: $source,
    OptionalAttr<TypedArrayAttrBase<JsirImportAttributeAttr, "">>: $assertions
  );

  let regions = (region
    OptionalRegion<StmtRegion>: $declaration
  );
}

def JsirExportAllDeclarationOp : Jsir_Op<
    "export_all_declaration", [
        JsirModuleDeclarationOpInterfaceTraits
    ]> {
  let arguments = (ins
    JsirStringLiteralAttr: $source,
    OptionalAttr<TypedArrayAttrBase<JsirImportAttributeAttr, "">>: $assertions
  );
}

#endif  // MALDOCA_JS_IR_JSIR_OPS_GENERATED_TD_
