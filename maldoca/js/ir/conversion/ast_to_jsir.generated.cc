// Copyright 2024 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// =============================================================================
// STOP!! DO NOT MODIFY!! THIS FILE IS AUTOMATICALLY GENERATED.
// =============================================================================

// IWYU pragma: begin_keep
// NOLINTBEGIN(whitespace/line_length)
// clang-format off

#include "maldoca/js/ir/conversion/ast_to_jsir.h"

#include <memory>
#include <utility>
#include <vector>

#include "llvm/ADT/APFloat.h"
#include "mlir/IR/Attributes.h"
#include "mlir/IR/Block.h"
#include "mlir/IR/Builders.h"
#include "mlir/IR/BuiltinAttributes.h"
#include "mlir/IR/BuiltinTypes.h"
#include "mlir/IR/Operation.h"
#include "mlir/IR/Region.h"
#include "mlir/IR/Value.h"
#include "absl/cleanup/cleanup.h"
#include "absl/log/check.h"
#include "absl/log/log.h"
#include "absl/types/optional.h"
#include "absl/types/variant.h"
#include "maldoca/js/ast/ast.generated.h"
#include "maldoca/js/ir/ir.h"

namespace maldoca {

JsirStatementOpInterface AstToJsir::VisitStatement(const JsStatement *node) {
  if (auto *expression_statement = dynamic_cast<const JsExpressionStatement *>(node)) {
    return VisitExpressionStatement(expression_statement);
  }
  if (auto *block_statement = dynamic_cast<const JsBlockStatement *>(node)) {
    return VisitBlockStatement(block_statement);
  }
  if (auto *empty_statement = dynamic_cast<const JsEmptyStatement *>(node)) {
    return VisitEmptyStatement(empty_statement);
  }
  if (auto *debugger_statement = dynamic_cast<const JsDebuggerStatement *>(node)) {
    return VisitDebuggerStatement(debugger_statement);
  }
  if (auto *with_statement = dynamic_cast<const JsWithStatement *>(node)) {
    return VisitWithStatement(with_statement);
  }
  if (auto *return_statement = dynamic_cast<const JsReturnStatement *>(node)) {
    return VisitReturnStatement(return_statement);
  }
  if (auto *labeled_statement = dynamic_cast<const JsLabeledStatement *>(node)) {
    return VisitLabeledStatement(labeled_statement);
  }
  if (auto *break_statement = dynamic_cast<const JsBreakStatement *>(node)) {
    return VisitBreakStatement(break_statement);
  }
  if (auto *continue_statement = dynamic_cast<const JsContinueStatement *>(node)) {
    return VisitContinueStatement(continue_statement);
  }
  if (auto *if_statement = dynamic_cast<const JsIfStatement *>(node)) {
    return VisitIfStatement(if_statement);
  }
  if (auto *switch_statement = dynamic_cast<const JsSwitchStatement *>(node)) {
    return VisitSwitchStatement(switch_statement);
  }
  if (auto *throw_statement = dynamic_cast<const JsThrowStatement *>(node)) {
    return VisitThrowStatement(throw_statement);
  }
  if (auto *try_statement = dynamic_cast<const JsTryStatement *>(node)) {
    return VisitTryStatement(try_statement);
  }
  if (auto *while_statement = dynamic_cast<const JsWhileStatement *>(node)) {
    return VisitWhileStatement(while_statement);
  }
  if (auto *do_while_statement = dynamic_cast<const JsDoWhileStatement *>(node)) {
    return VisitDoWhileStatement(do_while_statement);
  }
  if (auto *for_statement = dynamic_cast<const JsForStatement *>(node)) {
    return VisitForStatement(for_statement);
  }
  if (auto *for_in_statement = dynamic_cast<const JsForInStatement *>(node)) {
    return VisitForInStatement(for_in_statement);
  }
  if (auto *for_of_statement = dynamic_cast<const JsForOfStatement *>(node)) {
    return VisitForOfStatement(for_of_statement);
  }
  if (auto *function_declaration = dynamic_cast<const JsFunctionDeclaration *>(node)) {
    return VisitFunctionDeclaration(function_declaration);
  }
  if (auto *variable_declaration = dynamic_cast<const JsVariableDeclaration *>(node)) {
    return VisitVariableDeclaration(variable_declaration);
  }
  if (auto *class_declaration = dynamic_cast<const JsClassDeclaration *>(node)) {
    return VisitClassDeclaration(class_declaration);
  }
  LOG(FATAL) << "Unreachable code.";
}

JsirModuleDeclarationOpInterface AstToJsir::VisitModuleDeclaration(const JsModuleDeclaration *node) {
  if (auto *import_declaration = dynamic_cast<const JsImportDeclaration *>(node)) {
    return VisitImportDeclaration(import_declaration);
  }
  if (auto *export_named_declaration = dynamic_cast<const JsExportNamedDeclaration *>(node)) {
    return VisitExportNamedDeclaration(export_named_declaration);
  }
  if (auto *export_default_declaration = dynamic_cast<const JsExportDefaultDeclaration *>(node)) {
    return VisitExportDefaultDeclaration(export_default_declaration);
  }
  if (auto *export_all_declaration = dynamic_cast<const JsExportAllDeclaration *>(node)) {
    return VisitExportAllDeclaration(export_all_declaration);
  }
  LOG(FATAL) << "Unreachable code.";
}

JsirDirectiveLiteralOp AstToJsir::VisitDirectiveLiteral(const JsDirectiveLiteral *node) {
  mlir::StringAttr mlir_value = builder_.getStringAttr(node->value());
  JsirDirectiveLiteralExtraAttr mlir_extra;
  if (node->extra().has_value()) {
    mlir_extra = VisitDirectiveLiteralExtraAttr(node->extra().value());
  }
  return CreateExpr<JsirDirectiveLiteralOp>(node, mlir_value, mlir_extra);
}

JsirDirectiveOp AstToJsir::VisitDirective(const JsDirective *node) {
  mlir::Value mlir_value = VisitDirectiveLiteral(node->value());
  return CreateStmt<JsirDirectiveOp>(node, mlir_value);
}

JsirProgramOp AstToJsir::VisitProgram(const JsProgram *node) {
  JsirInterpreterDirectiveAttr mlir_interpreter;
  if (node->interpreter().has_value()) {
    mlir_interpreter = VisitInterpreterDirectiveAttr(node->interpreter().value());
  }
  mlir::StringAttr mlir_source_type = builder_.getStringAttr(node->source_type());
  auto op = CreateStmt<JsirProgramOp>(node, mlir_interpreter, mlir_source_type);
  mlir::Region &mlir_body_region = op.getBody();
  AppendNewBlockAndPopulate(mlir_body_region, [&] {
    for (const auto &element : *node->body()) {
      switch (element.index()) {
        case 0: {
          VisitStatement(std::get<0>(element).get());
          break;
        }
        case 1: {
          VisitModuleDeclaration(std::get<1>(element).get());
          break;
        }
        default:
          LOG(FATAL) << "Unreachable code.";
      }
    }
  });
  mlir::Region &mlir_directives_region = op.getDirectives();
  AppendNewBlockAndPopulate(mlir_directives_region, [&] {
    for (const auto &element : *node->directives()) {
      VisitDirective(element.get());
    }
  });
  return op;
}

JsirFileOp AstToJsir::VisitFile(const JsFile *node) {
  mlir::ArrayAttr mlir_comments;
  if (node->comments().has_value()) {
    std::vector<mlir::Attribute> mlir_comments_data;
    for (const auto &element : *node->comments().value()) {
      JsirCommentAttrInterface mlir_element = VisitCommentAttr(element.get());
      mlir_comments_data.push_back(std::move(mlir_element));
    }
    mlir_comments = builder_.getArrayAttr(mlir_comments_data);
  }
  auto op = CreateStmt<JsirFileOp>(node, mlir_comments);
  mlir::Region &mlir_program_region = op.getProgram();
  AppendNewBlockAndPopulate(mlir_program_region, [&] {
    VisitProgram(node->program());
  });
  return op;
}

JsirExpressionOpInterface AstToJsir::VisitExpression(const JsExpression *node) {
  if (auto *identifier = dynamic_cast<const JsIdentifier *>(node)) {
    return VisitIdentifier(identifier);
  }
  if (auto *reg_exp_literal = dynamic_cast<const JsRegExpLiteral *>(node)) {
    return VisitRegExpLiteral(reg_exp_literal);
  }
  if (auto *null_literal = dynamic_cast<const JsNullLiteral *>(node)) {
    return VisitNullLiteral(null_literal);
  }
  if (auto *string_literal = dynamic_cast<const JsStringLiteral *>(node)) {
    return VisitStringLiteral(string_literal);
  }
  if (auto *boolean_literal = dynamic_cast<const JsBooleanLiteral *>(node)) {
    return VisitBooleanLiteral(boolean_literal);
  }
  if (auto *numeric_literal = dynamic_cast<const JsNumericLiteral *>(node)) {
    return VisitNumericLiteral(numeric_literal);
  }
  if (auto *big_int_literal = dynamic_cast<const JsBigIntLiteral *>(node)) {
    return VisitBigIntLiteral(big_int_literal);
  }
  if (auto *this_expression = dynamic_cast<const JsThisExpression *>(node)) {
    return VisitThisExpression(this_expression);
  }
  if (auto *arrow_function_expression = dynamic_cast<const JsArrowFunctionExpression *>(node)) {
    return VisitArrowFunctionExpression(arrow_function_expression);
  }
  if (auto *yield_expression = dynamic_cast<const JsYieldExpression *>(node)) {
    return VisitYieldExpression(yield_expression);
  }
  if (auto *await_expression = dynamic_cast<const JsAwaitExpression *>(node)) {
    return VisitAwaitExpression(await_expression);
  }
  if (auto *array_expression = dynamic_cast<const JsArrayExpression *>(node)) {
    return VisitArrayExpression(array_expression);
  }
  if (auto *object_expression = dynamic_cast<const JsObjectExpression *>(node)) {
    return VisitObjectExpression(object_expression);
  }
  if (auto *function_expression = dynamic_cast<const JsFunctionExpression *>(node)) {
    return VisitFunctionExpression(function_expression);
  }
  if (auto *unary_expression = dynamic_cast<const JsUnaryExpression *>(node)) {
    return VisitUnaryExpression(unary_expression);
  }
  if (auto *update_expression = dynamic_cast<const JsUpdateExpression *>(node)) {
    return VisitUpdateExpression(update_expression);
  }
  if (auto *binary_expression = dynamic_cast<const JsBinaryExpression *>(node)) {
    return VisitBinaryExpression(binary_expression);
  }
  if (auto *assignment_expression = dynamic_cast<const JsAssignmentExpression *>(node)) {
    return VisitAssignmentExpression(assignment_expression);
  }
  if (auto *logical_expression = dynamic_cast<const JsLogicalExpression *>(node)) {
    return VisitLogicalExpression(logical_expression);
  }
  if (auto *member_expression = dynamic_cast<const JsMemberExpression *>(node)) {
    return VisitMemberExpression(member_expression);
  }
  if (auto *optional_member_expression = dynamic_cast<const JsOptionalMemberExpression *>(node)) {
    return VisitOptionalMemberExpression(optional_member_expression);
  }
  if (auto *conditional_expression = dynamic_cast<const JsConditionalExpression *>(node)) {
    return VisitConditionalExpression(conditional_expression);
  }
  if (auto *call_expression = dynamic_cast<const JsCallExpression *>(node)) {
    return VisitCallExpression(call_expression);
  }
  if (auto *optional_call_expression = dynamic_cast<const JsOptionalCallExpression *>(node)) {
    return VisitOptionalCallExpression(optional_call_expression);
  }
  if (auto *new_expression = dynamic_cast<const JsNewExpression *>(node)) {
    return VisitNewExpression(new_expression);
  }
  if (auto *sequence_expression = dynamic_cast<const JsSequenceExpression *>(node)) {
    return VisitSequenceExpression(sequence_expression);
  }
  if (auto *parenthesized_expression = dynamic_cast<const JsParenthesizedExpression *>(node)) {
    return VisitParenthesizedExpression(parenthesized_expression);
  }
  if (auto *template_literal = dynamic_cast<const JsTemplateLiteral *>(node)) {
    return VisitTemplateLiteral(template_literal);
  }
  if (auto *tagged_template_expression = dynamic_cast<const JsTaggedTemplateExpression *>(node)) {
    return VisitTaggedTemplateExpression(tagged_template_expression);
  }
  if (auto *class_expression = dynamic_cast<const JsClassExpression *>(node)) {
    return VisitClassExpression(class_expression);
  }
  if (auto *meta_property = dynamic_cast<const JsMetaProperty *>(node)) {
    return VisitMetaProperty(meta_property);
  }
  LOG(FATAL) << "Unreachable code.";
}

JsirPatternRefOpInterface AstToJsir::VisitPatternRef(const JsPattern *node) {
  if (auto *identifier = dynamic_cast<const JsIdentifier *>(node)) {
    return VisitIdentifierRef(identifier);
  }
  if (auto *member_expression = dynamic_cast<const JsMemberExpression *>(node)) {
    return VisitMemberExpressionRef(member_expression);
  }
  if (auto *parenthesized_expression = dynamic_cast<const JsParenthesizedExpression *>(node)) {
    return VisitParenthesizedExpressionRef(parenthesized_expression);
  }
  if (auto *object_pattern = dynamic_cast<const JsObjectPattern *>(node)) {
    return VisitObjectPatternRef(object_pattern);
  }
  if (auto *array_pattern = dynamic_cast<const JsArrayPattern *>(node)) {
    return VisitArrayPatternRef(array_pattern);
  }
  if (auto *rest_element = dynamic_cast<const JsRestElement *>(node)) {
    return VisitRestElementRef(rest_element);
  }
  if (auto *assignment_pattern = dynamic_cast<const JsAssignmentPattern *>(node)) {
    return VisitAssignmentPatternRef(assignment_pattern);
  }
  LOG(FATAL) << "Unreachable code.";
}

JsirLValRefOpInterface AstToJsir::VisitLValRef(const JsLVal *node) {
  if (auto *identifier = dynamic_cast<const JsIdentifier *>(node)) {
    return VisitIdentifierRef(identifier);
  }
  if (auto *member_expression = dynamic_cast<const JsMemberExpression *>(node)) {
    return VisitMemberExpressionRef(member_expression);
  }
  if (auto *parenthesized_expression = dynamic_cast<const JsParenthesizedExpression *>(node)) {
    return VisitParenthesizedExpressionRef(parenthesized_expression);
  }
  if (auto *object_pattern = dynamic_cast<const JsObjectPattern *>(node)) {
    return VisitObjectPatternRef(object_pattern);
  }
  if (auto *array_pattern = dynamic_cast<const JsArrayPattern *>(node)) {
    return VisitArrayPatternRef(array_pattern);
  }
  if (auto *rest_element = dynamic_cast<const JsRestElement *>(node)) {
    return VisitRestElementRef(rest_element);
  }
  if (auto *assignment_pattern = dynamic_cast<const JsAssignmentPattern *>(node)) {
    return VisitAssignmentPatternRef(assignment_pattern);
  }
  LOG(FATAL) << "Unreachable code.";
}

JsirIdentifierOp AstToJsir::VisitIdentifier(const JsIdentifier *node) {
  mlir::StringAttr mlir_name = builder_.getStringAttr(node->name());
  return CreateExpr<JsirIdentifierOp>(node, mlir_name);
}

JsirIdentifierRefOp AstToJsir::VisitIdentifierRef(const JsIdentifier *node) {
  mlir::StringAttr mlir_name = builder_.getStringAttr(node->name());
  return CreateExpr<JsirIdentifierRefOp>(node, mlir_name);
}

JsirPrivateNameOp AstToJsir::VisitPrivateName(const JsPrivateName *node) {
  JsirIdentifierAttr mlir_id = VisitIdentifierAttr(node->id());
  return CreateExpr<JsirPrivateNameOp>(node, mlir_id);
}

JsirLiteralOpInterface AstToJsir::VisitLiteral(const JsLiteral *node) {
  if (auto *reg_exp_literal = dynamic_cast<const JsRegExpLiteral *>(node)) {
    return VisitRegExpLiteral(reg_exp_literal);
  }
  if (auto *null_literal = dynamic_cast<const JsNullLiteral *>(node)) {
    return VisitNullLiteral(null_literal);
  }
  if (auto *string_literal = dynamic_cast<const JsStringLiteral *>(node)) {
    return VisitStringLiteral(string_literal);
  }
  if (auto *boolean_literal = dynamic_cast<const JsBooleanLiteral *>(node)) {
    return VisitBooleanLiteral(boolean_literal);
  }
  if (auto *numeric_literal = dynamic_cast<const JsNumericLiteral *>(node)) {
    return VisitNumericLiteral(numeric_literal);
  }
  if (auto *big_int_literal = dynamic_cast<const JsBigIntLiteral *>(node)) {
    return VisitBigIntLiteral(big_int_literal);
  }
  LOG(FATAL) << "Unreachable code.";
}

JsirRegExpLiteralOp AstToJsir::VisitRegExpLiteral(const JsRegExpLiteral *node) {
  mlir::StringAttr mlir_pattern = builder_.getStringAttr(node->pattern());
  mlir::StringAttr mlir_flags = builder_.getStringAttr(node->flags());
  JsirRegExpLiteralExtraAttr mlir_extra;
  if (node->extra().has_value()) {
    mlir_extra = VisitRegExpLiteralExtraAttr(node->extra().value());
  }
  return CreateExpr<JsirRegExpLiteralOp>(node, mlir_pattern, mlir_flags, mlir_extra);
}

JsirNullLiteralOp AstToJsir::VisitNullLiteral(const JsNullLiteral *node) {
  return CreateExpr<JsirNullLiteralOp>(node);
}

JsirStringLiteralOp AstToJsir::VisitStringLiteral(const JsStringLiteral *node) {
  mlir::StringAttr mlir_value = builder_.getStringAttr(node->value());
  JsirStringLiteralExtraAttr mlir_extra;
  if (node->extra().has_value()) {
    mlir_extra = VisitStringLiteralExtraAttr(node->extra().value());
  }
  return CreateExpr<JsirStringLiteralOp>(node, mlir_value, mlir_extra);
}

JsirBooleanLiteralOp AstToJsir::VisitBooleanLiteral(const JsBooleanLiteral *node) {
  mlir::BoolAttr mlir_value = builder_.getBoolAttr(node->value());
  return CreateExpr<JsirBooleanLiteralOp>(node, mlir_value);
}

JsirNumericLiteralOp AstToJsir::VisitNumericLiteral(const JsNumericLiteral *node) {
  mlir::FloatAttr mlir_value = builder_.getF64FloatAttr(node->value());
  JsirNumericLiteralExtraAttr mlir_extra;
  if (node->extra().has_value()) {
    mlir_extra = VisitNumericLiteralExtraAttr(node->extra().value());
  }
  return CreateExpr<JsirNumericLiteralOp>(node, mlir_value, mlir_extra);
}

JsirBigIntLiteralOp AstToJsir::VisitBigIntLiteral(const JsBigIntLiteral *node) {
  mlir::StringAttr mlir_value = builder_.getStringAttr(node->value());
  JsirBigIntLiteralExtraAttr mlir_extra;
  if (node->extra().has_value()) {
    mlir_extra = VisitBigIntLiteralExtraAttr(node->extra().value());
  }
  return CreateExpr<JsirBigIntLiteralOp>(node, mlir_value, mlir_extra);
}

JshirBlockStatementOp AstToJsir::VisitBlockStatement(const JsBlockStatement *node) {
  auto op = CreateStmt<JshirBlockStatementOp>(node);
  mlir::Region &mlir_body_region = op.getBody();
  AppendNewBlockAndPopulate(mlir_body_region, [&] {
    for (const auto &element : *node->body()) {
      VisitStatement(element.get());
    }
  });
  mlir::Region &mlir_directives_region = op.getDirectives();
  AppendNewBlockAndPopulate(mlir_directives_region, [&] {
    for (const auto &element : *node->directives()) {
      VisitDirective(element.get());
    }
  });
  return op;
}

JsirExpressionStatementOp AstToJsir::VisitExpressionStatement(const JsExpressionStatement *node) {
  mlir::Value mlir_expression = VisitExpression(node->expression());
  return CreateStmt<JsirExpressionStatementOp>(node, mlir_expression);
}

JsirEmptyStatementOp AstToJsir::VisitEmptyStatement(const JsEmptyStatement *node) {
  return CreateStmt<JsirEmptyStatementOp>(node);
}

JsirDebuggerStatementOp AstToJsir::VisitDebuggerStatement(const JsDebuggerStatement *node) {
  return CreateStmt<JsirDebuggerStatementOp>(node);
}

JshirWithStatementOp AstToJsir::VisitWithStatement(const JsWithStatement *node) {
  mlir::Value mlir_object = VisitExpression(node->object());
  auto op = CreateStmt<JshirWithStatementOp>(node, mlir_object);
  mlir::Region &mlir_body_region = op.getBody();
  AppendNewBlockAndPopulate(mlir_body_region, [&] {
    VisitStatement(node->body());
  });
  return op;
}

JsirReturnStatementOp AstToJsir::VisitReturnStatement(const JsReturnStatement *node) {
  mlir::Value mlir_argument;
  if (node->argument().has_value()) {
    mlir_argument = VisitExpression(node->argument().value());
  }
  return CreateStmt<JsirReturnStatementOp>(node, mlir_argument);
}

JshirLabeledStatementOp AstToJsir::VisitLabeledStatement(const JsLabeledStatement *node) {
  JsirIdentifierAttr mlir_label = VisitIdentifierAttr(node->label());
  auto op = CreateStmt<JshirLabeledStatementOp>(node, mlir_label);
  mlir::Region &mlir_body_region = op.getBody();
  AppendNewBlockAndPopulate(mlir_body_region, [&] {
    VisitStatement(node->body());
  });
  return op;
}

JshirIfStatementOp AstToJsir::VisitIfStatement(const JsIfStatement *node) {
  mlir::Value mlir_test = VisitExpression(node->test());
  auto op = CreateStmt<JshirIfStatementOp>(node, mlir_test);
  mlir::Region &mlir_consequent_region = op.getConsequent();
  AppendNewBlockAndPopulate(mlir_consequent_region, [&] {
    VisitStatement(node->consequent());
  });
  if (node->alternate().has_value()) {
    mlir::Region &mlir_alternate_region = op.getAlternate();
    AppendNewBlockAndPopulate(mlir_alternate_region, [&] {
      VisitStatement(node->alternate().value());
    });
  }
  return op;
}

JshirSwitchCaseOp AstToJsir::VisitSwitchCase(const JsSwitchCase *node) {
  auto op = CreateStmt<JshirSwitchCaseOp>(node);
  if (node->test().has_value()) {
    mlir::Region &mlir_test_region = op.getTest();
    AppendNewBlockAndPopulate(mlir_test_region, [&] {
      mlir::Value mlir_test = VisitExpression(node->test().value());
      CreateStmt<JsirExprRegionEndOp>(node, mlir_test);
    });
  }
  mlir::Region &mlir_consequent_region = op.getConsequent();
  AppendNewBlockAndPopulate(mlir_consequent_region, [&] {
    for (const auto &element : *node->consequent()) {
      VisitStatement(element.get());
    }
  });
  return op;
}

JshirSwitchStatementOp AstToJsir::VisitSwitchStatement(const JsSwitchStatement *node) {
  mlir::Value mlir_discriminant = VisitExpression(node->discriminant());
  auto op = CreateStmt<JshirSwitchStatementOp>(node, mlir_discriminant);
  mlir::Region &mlir_cases_region = op.getCases();
  AppendNewBlockAndPopulate(mlir_cases_region, [&] {
    for (const auto &element : *node->cases()) {
      VisitSwitchCase(element.get());
    }
  });
  return op;
}

JsirThrowStatementOp AstToJsir::VisitThrowStatement(const JsThrowStatement *node) {
  mlir::Value mlir_argument = VisitExpression(node->argument());
  return CreateStmt<JsirThrowStatementOp>(node, mlir_argument);
}

JshirCatchClauseOp AstToJsir::VisitCatchClause(const JsCatchClause *node) {
  mlir::Value mlir_param;
  if (node->param().has_value()) {
    mlir_param = VisitPatternRef(node->param().value());
  }
  auto op = CreateStmt<JshirCatchClauseOp>(node, mlir_param);
  mlir::Region &mlir_body_region = op.getBody();
  AppendNewBlockAndPopulate(mlir_body_region, [&] {
    VisitBlockStatement(node->body());
  });
  return op;
}

JshirTryStatementOp AstToJsir::VisitTryStatement(const JsTryStatement *node) {
  auto op = CreateStmt<JshirTryStatementOp>(node);
  mlir::Region &mlir_block_region = op.getBlock();
  AppendNewBlockAndPopulate(mlir_block_region, [&] {
    VisitBlockStatement(node->block());
  });
  if (node->handler().has_value()) {
    mlir::Region &mlir_handler_region = op.getHandler();
    AppendNewBlockAndPopulate(mlir_handler_region, [&] {
      VisitCatchClause(node->handler().value());
    });
  }
  if (node->finalizer().has_value()) {
    mlir::Region &mlir_finalizer_region = op.getFinalizer();
    AppendNewBlockAndPopulate(mlir_finalizer_region, [&] {
      VisitBlockStatement(node->finalizer().value());
    });
  }
  return op;
}

JshirWhileStatementOp AstToJsir::VisitWhileStatement(const JsWhileStatement *node) {
  auto op = CreateStmt<JshirWhileStatementOp>(node);
  mlir::Region &mlir_test_region = op.getTest();
  AppendNewBlockAndPopulate(mlir_test_region, [&] {
    mlir::Value mlir_test = VisitExpression(node->test());
    CreateStmt<JsirExprRegionEndOp>(node, mlir_test);
  });
  mlir::Region &mlir_body_region = op.getBody();
  AppendNewBlockAndPopulate(mlir_body_region, [&] {
    VisitStatement(node->body());
  });
  return op;
}

JshirDoWhileStatementOp AstToJsir::VisitDoWhileStatement(const JsDoWhileStatement *node) {
  auto op = CreateStmt<JshirDoWhileStatementOp>(node);
  mlir::Region &mlir_body_region = op.getBody();
  AppendNewBlockAndPopulate(mlir_body_region, [&] {
    VisitStatement(node->body());
  });
  mlir::Region &mlir_test_region = op.getTest();
  AppendNewBlockAndPopulate(mlir_test_region, [&] {
    mlir::Value mlir_test = VisitExpression(node->test());
    CreateStmt<JsirExprRegionEndOp>(node, mlir_test);
  });
  return op;
}

JsirDeclarationOpInterface AstToJsir::VisitDeclaration(const JsDeclaration *node) {
  if (auto *function_declaration = dynamic_cast<const JsFunctionDeclaration *>(node)) {
    return VisitFunctionDeclaration(function_declaration);
  }
  if (auto *variable_declaration = dynamic_cast<const JsVariableDeclaration *>(node)) {
    return VisitVariableDeclaration(variable_declaration);
  }
  if (auto *class_declaration = dynamic_cast<const JsClassDeclaration *>(node)) {
    return VisitClassDeclaration(class_declaration);
  }
  LOG(FATAL) << "Unreachable code.";
}

JsirVariableDeclaratorOp AstToJsir::VisitVariableDeclarator(const JsVariableDeclarator *node) {
  mlir::Value mlir_id = VisitLValRef(node->id());
  mlir::Value mlir_init;
  if (node->init().has_value()) {
    mlir_init = VisitExpression(node->init().value());
  }
  return CreateExpr<JsirVariableDeclaratorOp>(node, mlir_id, mlir_init);
}

JsirVariableDeclarationOp AstToJsir::VisitVariableDeclaration(const JsVariableDeclaration *node) {
  mlir::StringAttr mlir_kind = builder_.getStringAttr(node->kind());
  auto op = CreateStmt<JsirVariableDeclarationOp>(node, mlir_kind);
  mlir::Region &mlir_declarations_region = op.getDeclarations();
  AppendNewBlockAndPopulate(mlir_declarations_region, [&] {
    std::vector<mlir::Value> mlir_declarations;
    for (const auto &element : *node->declarations()) {
      mlir::Value mlir_element = VisitVariableDeclarator(element.get());
      mlir_declarations.push_back(std::move(mlir_element));
    }
    CreateStmt<JsirExprsRegionEndOp>(node, mlir_declarations);
  });
  return op;
}

JsirFunctionDeclarationOp AstToJsir::VisitFunctionDeclaration(const JsFunctionDeclaration *node) {
  JsirIdentifierAttr mlir_id;
  if (node->id().has_value()) {
    mlir_id = VisitIdentifierAttr(node->id().value());
  }
  mlir::BoolAttr mlir_generator = builder_.getBoolAttr(node->generator());
  mlir::BoolAttr mlir_async = builder_.getBoolAttr(node->async());
  auto op = CreateStmt<JsirFunctionDeclarationOp>(node, mlir_id, mlir_generator, mlir_async);
  mlir::Region &mlir_params_region = op.getParams();
  AppendNewBlockAndPopulate(mlir_params_region, [&] {
    std::vector<mlir::Value> mlir_params;
    for (const auto &element : *node->params()) {
      mlir::Value mlir_element = VisitPatternRef(element.get());
      mlir_params.push_back(std::move(mlir_element));
    }
    CreateStmt<JsirExprsRegionEndOp>(node, mlir_params);
  });
  mlir::Region &mlir_body_region = op.getBody();
  AppendNewBlockAndPopulate(mlir_body_region, [&] {
    VisitBlockStatement(node->body());
  });
  return op;
}

JsirSuperOp AstToJsir::VisitSuper(const JsSuper *node) {
  return CreateExpr<JsirSuperOp>(node);
}

JsirImportOp AstToJsir::VisitImport(const JsImport *node) {
  return CreateExpr<JsirImportOp>(node);
}

JsirThisExpressionOp AstToJsir::VisitThisExpression(const JsThisExpression *node) {
  return CreateExpr<JsirThisExpressionOp>(node);
}

JsirYieldExpressionOp AstToJsir::VisitYieldExpression(const JsYieldExpression *node) {
  mlir::Value mlir_argument;
  if (node->argument().has_value()) {
    mlir_argument = VisitExpression(node->argument().value());
  }
  mlir::BoolAttr mlir_delegate = builder_.getBoolAttr(node->delegate());
  return CreateExpr<JsirYieldExpressionOp>(node, mlir_argument, mlir_delegate);
}

JsirAwaitExpressionOp AstToJsir::VisitAwaitExpression(const JsAwaitExpression *node) {
  mlir::Value mlir_argument;
  if (node->argument().has_value()) {
    mlir_argument = VisitExpression(node->argument().value());
  }
  return CreateExpr<JsirAwaitExpressionOp>(node, mlir_argument);
}

JsirSpreadElementOp AstToJsir::VisitSpreadElement(const JsSpreadElement *node) {
  mlir::Value mlir_argument = VisitExpression(node->argument());
  return CreateExpr<JsirSpreadElementOp>(node, mlir_argument);
}

JsirArrayExpressionOp AstToJsir::VisitArrayExpression(const JsArrayExpression *node) {
  std::vector<mlir::Value> mlir_elements;
  for (const auto &element : *node->elements()) {
    mlir::Value mlir_element;
    if (element.has_value()) {
      switch (element.value().index()) {
        case 0: {
          mlir_element = VisitExpression(std::get<0>(element.value()).get());
          break;
        }
        case 1: {
          mlir_element = VisitSpreadElement(std::get<1>(element.value()).get());
          break;
        }
        default:
          LOG(FATAL) << "Unreachable code.";
      }
    } else {
      mlir_element = CreateExpr<JsirNoneOp>(node);
    }
    mlir_elements.push_back(std::move(mlir_element));
  }
  return CreateExpr<JsirArrayExpressionOp>(node, mlir_elements);
}

JsirFunctionExpressionOp AstToJsir::VisitFunctionExpression(const JsFunctionExpression *node) {
  JsirIdentifierAttr mlir_id;
  if (node->id().has_value()) {
    mlir_id = VisitIdentifierAttr(node->id().value());
  }
  mlir::BoolAttr mlir_generator = builder_.getBoolAttr(node->generator());
  mlir::BoolAttr mlir_async = builder_.getBoolAttr(node->async());
  auto op = CreateExpr<JsirFunctionExpressionOp>(node, mlir_id, mlir_generator, mlir_async);
  mlir::Region &mlir_params_region = op.getParams();
  AppendNewBlockAndPopulate(mlir_params_region, [&] {
    std::vector<mlir::Value> mlir_params;
    for (const auto &element : *node->params()) {
      mlir::Value mlir_element = VisitPatternRef(element.get());
      mlir_params.push_back(std::move(mlir_element));
    }
    CreateStmt<JsirExprsRegionEndOp>(node, mlir_params);
  });
  mlir::Region &mlir_body_region = op.getBody();
  AppendNewBlockAndPopulate(mlir_body_region, [&] {
    VisitBlockStatement(node->body());
  });
  return op;
}

JsirUnaryExpressionOp AstToJsir::VisitUnaryExpression(const JsUnaryExpression *node) {
  mlir::StringAttr mlir_operator = builder_.getStringAttr(JsUnaryOperatorToString(node->operator_()));
  mlir::BoolAttr mlir_prefix = builder_.getBoolAttr(node->prefix());
  mlir::Value mlir_argument = VisitExpression(node->argument());
  return CreateExpr<JsirUnaryExpressionOp>(node, mlir_operator, mlir_prefix, mlir_argument);
}

JsirUpdateExpressionOp AstToJsir::VisitUpdateExpression(const JsUpdateExpression *node) {
  mlir::StringAttr mlir_operator = builder_.getStringAttr(JsUpdateOperatorToString(node->operator_()));
  mlir::Value mlir_argument = VisitLValRef(node->argument());
  mlir::BoolAttr mlir_prefix = builder_.getBoolAttr(node->prefix());
  return CreateExpr<JsirUpdateExpressionOp>(node, mlir_operator, mlir_argument, mlir_prefix);
}

JsirBinaryExpressionOp AstToJsir::VisitBinaryExpression(const JsBinaryExpression *node) {
  mlir::StringAttr mlir_operator = builder_.getStringAttr(JsBinaryOperatorToString(node->operator_()));
  mlir::Value mlir_left;
  switch (node->left().index()) {
    case 0: {
      mlir_left = VisitExpression(std::get<0>(node->left()));
      break;
    }
    case 1: {
      mlir_left = VisitPrivateName(std::get<1>(node->left()));
      break;
    }
    default:
      LOG(FATAL) << "Unreachable code.";
  }
  mlir::Value mlir_right = VisitExpression(node->right());
  return CreateExpr<JsirBinaryExpressionOp>(node, mlir_operator, mlir_left, mlir_right);
}

JsirAssignmentExpressionOp AstToJsir::VisitAssignmentExpression(const JsAssignmentExpression *node) {
  mlir::StringAttr mlir_operator = builder_.getStringAttr(JsAssignmentOperatorToString(node->operator_()));
  mlir::Value mlir_left = VisitLValRef(node->left());
  mlir::Value mlir_right = VisitExpression(node->right());
  return CreateExpr<JsirAssignmentExpressionOp>(node, mlir_operator, mlir_left, mlir_right);
}

JshirLogicalExpressionOp AstToJsir::VisitLogicalExpression(const JsLogicalExpression *node) {
  mlir::StringAttr mlir_operator = builder_.getStringAttr(JsLogicalOperatorToString(node->operator_()));
  mlir::Value mlir_left = VisitExpression(node->left());
  auto op = CreateExpr<JshirLogicalExpressionOp>(node, mlir_operator, mlir_left);
  mlir::Region &mlir_right_region = op.getRight();
  AppendNewBlockAndPopulate(mlir_right_region, [&] {
    mlir::Value mlir_right = VisitExpression(node->right());
    CreateStmt<JsirExprRegionEndOp>(node, mlir_right);
  });
  return op;
}

JshirConditionalExpressionOp AstToJsir::VisitConditionalExpression(const JsConditionalExpression *node) {
  mlir::Value mlir_test = VisitExpression(node->test());
  auto op = CreateExpr<JshirConditionalExpressionOp>(node, mlir_test);
  mlir::Region &mlir_alternate_region = op.getAlternate();
  AppendNewBlockAndPopulate(mlir_alternate_region, [&] {
    mlir::Value mlir_alternate = VisitExpression(node->alternate());
    CreateStmt<JsirExprRegionEndOp>(node, mlir_alternate);
  });
  mlir::Region &mlir_consequent_region = op.getConsequent();
  AppendNewBlockAndPopulate(mlir_consequent_region, [&] {
    mlir::Value mlir_consequent = VisitExpression(node->consequent());
    CreateStmt<JsirExprRegionEndOp>(node, mlir_consequent);
  });
  return op;
}

JsirCallExpressionOp AstToJsir::VisitCallExpression(const JsCallExpression *node) {
  mlir::Value mlir_callee;
  switch (node->callee().index()) {
    case 0: {
      mlir_callee = VisitExpression(std::get<0>(node->callee()));
      break;
    }
    case 1: {
      mlir_callee = VisitSuper(std::get<1>(node->callee()));
      break;
    }
    case 2: {
      mlir_callee = VisitImport(std::get<2>(node->callee()));
      break;
    }
    default:
      LOG(FATAL) << "Unreachable code.";
  }
  std::vector<mlir::Value> mlir_arguments;
  for (const auto &element : *node->arguments()) {
    mlir::Value mlir_element;
    switch (element.index()) {
      case 0: {
        mlir_element = VisitExpression(std::get<0>(element).get());
        break;
      }
      case 1: {
        mlir_element = VisitSpreadElement(std::get<1>(element).get());
        break;
      }
      default:
        LOG(FATAL) << "Unreachable code.";
    }
    mlir_arguments.push_back(std::move(mlir_element));
  }
  return CreateExpr<JsirCallExpressionOp>(node, mlir_callee, mlir_arguments);
}

JsirOptionalCallExpressionOp AstToJsir::VisitOptionalCallExpression(const JsOptionalCallExpression *node) {
  mlir::Value mlir_callee = VisitExpression(node->callee());
  std::vector<mlir::Value> mlir_arguments;
  for (const auto &element : *node->arguments()) {
    mlir::Value mlir_element;
    switch (element.index()) {
      case 0: {
        mlir_element = VisitExpression(std::get<0>(element).get());
        break;
      }
      case 1: {
        mlir_element = VisitSpreadElement(std::get<1>(element).get());
        break;
      }
      default:
        LOG(FATAL) << "Unreachable code.";
    }
    mlir_arguments.push_back(std::move(mlir_element));
  }
  mlir::BoolAttr mlir_optional = builder_.getBoolAttr(node->optional());
  return CreateExpr<JsirOptionalCallExpressionOp>(node, mlir_callee, mlir_arguments, mlir_optional);
}

JsirNewExpressionOp AstToJsir::VisitNewExpression(const JsNewExpression *node) {
  mlir::Value mlir_callee;
  switch (node->callee().index()) {
    case 0: {
      mlir_callee = VisitExpression(std::get<0>(node->callee()));
      break;
    }
    case 1: {
      mlir_callee = VisitSuper(std::get<1>(node->callee()));
      break;
    }
    case 2: {
      mlir_callee = VisitImport(std::get<2>(node->callee()));
      break;
    }
    default:
      LOG(FATAL) << "Unreachable code.";
  }
  std::vector<mlir::Value> mlir_arguments;
  for (const auto &element : *node->arguments()) {
    mlir::Value mlir_element;
    switch (element.index()) {
      case 0: {
        mlir_element = VisitExpression(std::get<0>(element).get());
        break;
      }
      case 1: {
        mlir_element = VisitSpreadElement(std::get<1>(element).get());
        break;
      }
      default:
        LOG(FATAL) << "Unreachable code.";
    }
    mlir_arguments.push_back(std::move(mlir_element));
  }
  return CreateExpr<JsirNewExpressionOp>(node, mlir_callee, mlir_arguments);
}

JsirSequenceExpressionOp AstToJsir::VisitSequenceExpression(const JsSequenceExpression *node) {
  std::vector<mlir::Value> mlir_expressions;
  for (const auto &element : *node->expressions()) {
    mlir::Value mlir_element = VisitExpression(element.get());
    mlir_expressions.push_back(std::move(mlir_element));
  }
  return CreateExpr<JsirSequenceExpressionOp>(node, mlir_expressions);
}

JsirTemplateElementValueOp AstToJsir::VisitTemplateElementValue(const JsTemplateElementValue *node) {
  mlir::StringAttr mlir_cooked;
  if (node->cooked().has_value()) {
    mlir_cooked = builder_.getStringAttr(node->cooked().value());
  }
  mlir::StringAttr mlir_raw = builder_.getStringAttr(node->raw());
  return CreateExpr<JsirTemplateElementValueOp>(node, mlir_cooked, mlir_raw);
}

JsirTemplateElementOp AstToJsir::VisitTemplateElement(const JsTemplateElement *node) {
  mlir::BoolAttr mlir_tail = builder_.getBoolAttr(node->tail());
  mlir::Value mlir_value = VisitTemplateElementValue(node->value());
  return CreateExpr<JsirTemplateElementOp>(node, mlir_tail, mlir_value);
}

JsirTemplateLiteralOp AstToJsir::VisitTemplateLiteral(const JsTemplateLiteral *node) {
  std::vector<mlir::Value> mlir_quasis;
  for (const auto &element : *node->quasis()) {
    mlir::Value mlir_element = VisitTemplateElement(element.get());
    mlir_quasis.push_back(std::move(mlir_element));
  }
  std::vector<mlir::Value> mlir_expressions;
  for (const auto &element : *node->expressions()) {
    mlir::Value mlir_element = VisitExpression(element.get());
    mlir_expressions.push_back(std::move(mlir_element));
  }
  return CreateExpr<JsirTemplateLiteralOp>(node, mlir_quasis, mlir_expressions);
}

JsirTaggedTemplateExpressionOp AstToJsir::VisitTaggedTemplateExpression(const JsTaggedTemplateExpression *node) {
  mlir::Value mlir_tag = VisitExpression(node->tag());
  mlir::Value mlir_quasi = VisitTemplateLiteral(node->quasi());
  return CreateExpr<JsirTaggedTemplateExpressionOp>(node, mlir_tag, mlir_quasi);
}

JsirRestElementRefOp AstToJsir::VisitRestElementRef(const JsRestElement *node) {
  mlir::Value mlir_argument = VisitLValRef(node->argument());
  return CreateExpr<JsirRestElementRefOp>(node, mlir_argument);
}

JsirObjectPatternRefOp AstToJsir::VisitObjectPatternRef(const JsObjectPattern *node) {
  auto op = CreateExpr<JsirObjectPatternRefOp>(node);
  mlir::Region &mlir_properties_region = op.getProperties_();
  AppendNewBlockAndPopulate(mlir_properties_region, [&] {
    std::vector<mlir::Value> mlir_properties;
    for (const auto &element : *node->properties_()) {
      mlir::Value mlir_element;
      switch (element.index()) {
        case 0: {
          mlir_element = VisitObjectPropertyRef(std::get<0>(element).get());
          break;
        }
        case 1: {
          mlir_element = VisitRestElementRef(std::get<1>(element).get());
          break;
        }
        default:
          LOG(FATAL) << "Unreachable code.";
      }
      mlir_properties.push_back(std::move(mlir_element));
    }
    CreateStmt<JsirExprsRegionEndOp>(node, mlir_properties);
  });
  return op;
}

JsirArrayPatternRefOp AstToJsir::VisitArrayPatternRef(const JsArrayPattern *node) {
  std::vector<mlir::Value> mlir_elements;
  for (const auto &element : *node->elements()) {
    mlir::Value mlir_element;
    if (element.has_value()) {
      mlir_element = VisitPatternRef(element.value().get());
    } else {
      mlir_element = CreateExpr<JsirNoneOp>(node);
    }
    mlir_elements.push_back(std::move(mlir_element));
  }
  return CreateExpr<JsirArrayPatternRefOp>(node, mlir_elements);
}

JsirAssignmentPatternRefOp AstToJsir::VisitAssignmentPatternRef(const JsAssignmentPattern *node) {
  mlir::Value mlir_left = VisitPatternRef(node->left());
  mlir::Value mlir_right = VisitExpression(node->right());
  return CreateExpr<JsirAssignmentPatternRefOp>(node, mlir_left, mlir_right);
}

JsirClassPrivatePropertyOp AstToJsir::VisitClassPrivateProperty(const JsClassPrivateProperty *node) {
  JsirPrivateNameAttr mlir_key = VisitPrivateNameAttr(node->key());
  mlir::BoolAttr mlir_static = builder_.getBoolAttr(node->static_());
  auto op = CreateStmt<JsirClassPrivatePropertyOp>(node, mlir_key, mlir_static);
  if (node->value().has_value()) {
    mlir::Region &mlir_value_region = op.getValue();
    AppendNewBlockAndPopulate(mlir_value_region, [&] {
      mlir::Value mlir_value = VisitExpression(node->value().value());
      CreateStmt<JsirExprRegionEndOp>(node, mlir_value);
    });
  }
  return op;
}

JsirClassBodyOp AstToJsir::VisitClassBody(const JsClassBody *node) {
  auto op = CreateStmt<JsirClassBodyOp>(node);
  mlir::Region &mlir_body_region = op.getBody();
  AppendNewBlockAndPopulate(mlir_body_region, [&] {
    for (const auto &element : *node->body()) {
      switch (element.index()) {
        case 0: {
          VisitClassMethod(std::get<0>(element).get());
          break;
        }
        case 1: {
          VisitClassPrivateMethod(std::get<1>(element).get());
          break;
        }
        case 2: {
          VisitClassProperty(std::get<2>(element).get());
          break;
        }
        case 3: {
          VisitClassPrivateProperty(std::get<3>(element).get());
          break;
        }
        default:
          LOG(FATAL) << "Unreachable code.";
      }
    }
  });
  return op;
}

JsirClassDeclarationOp AstToJsir::VisitClassDeclaration(const JsClassDeclaration *node) {
  mlir::Value mlir_super_class;
  if (node->super_class().has_value()) {
    mlir_super_class = VisitExpression(node->super_class().value());
  }
  JsirIdentifierAttr mlir_id;
  if (node->id().has_value()) {
    mlir_id = VisitIdentifierAttr(node->id().value());
  }
  auto op = CreateStmt<JsirClassDeclarationOp>(node, mlir_super_class, mlir_id);
  mlir::Region &mlir_body_region = op.getBody();
  AppendNewBlockAndPopulate(mlir_body_region, [&] {
    VisitClassBody(node->body());
  });
  return op;
}

JsirClassExpressionOp AstToJsir::VisitClassExpression(const JsClassExpression *node) {
  mlir::Value mlir_super_class;
  if (node->super_class().has_value()) {
    mlir_super_class = VisitExpression(node->super_class().value());
  }
  JsirIdentifierAttr mlir_id;
  if (node->id().has_value()) {
    mlir_id = VisitIdentifierAttr(node->id().value());
  }
  auto op = CreateExpr<JsirClassExpressionOp>(node, mlir_super_class, mlir_id);
  mlir::Region &mlir_body_region = op.getBody();
  AppendNewBlockAndPopulate(mlir_body_region, [&] {
    VisitClassBody(node->body());
  });
  return op;
}

JsirMetaPropertyOp AstToJsir::VisitMetaProperty(const JsMetaProperty *node) {
  JsirIdentifierAttr mlir_meta = VisitIdentifierAttr(node->meta());
  JsirIdentifierAttr mlir_property = VisitIdentifierAttr(node->property());
  return CreateExpr<JsirMetaPropertyOp>(node, mlir_meta, mlir_property);
}

JsirModuleSpecifierAttrInterface AstToJsir::VisitModuleSpecifierAttr(const JsModuleSpecifier *node) {
  if (auto *import_specifier = dynamic_cast<const JsImportSpecifier *>(node)) {
    return VisitImportSpecifierAttr(import_specifier);
  }
  if (auto *import_default_specifier = dynamic_cast<const JsImportDefaultSpecifier *>(node)) {
    return VisitImportDefaultSpecifierAttr(import_default_specifier);
  }
  if (auto *import_namespace_specifier = dynamic_cast<const JsImportNamespaceSpecifier *>(node)) {
    return VisitImportNamespaceSpecifierAttr(import_namespace_specifier);
  }
  if (auto *export_specifier = dynamic_cast<const JsExportSpecifier *>(node)) {
    return VisitExportSpecifierAttr(export_specifier);
  }
  LOG(FATAL) << "Unreachable code.";
}

JsirImportDeclarationOp AstToJsir::VisitImportDeclaration(const JsImportDeclaration *node) {
  std::vector<mlir::Attribute> mlir_specifiers_data;
  for (const auto &element : *node->specifiers()) {
    mlir::Attribute mlir_element;
    switch (element.index()) {
      case 0: {
        mlir_element = VisitImportSpecifierAttr(std::get<0>(element).get());
        break;
      }
      case 1: {
        mlir_element = VisitImportDefaultSpecifierAttr(std::get<1>(element).get());
        break;
      }
      case 2: {
        mlir_element = VisitImportNamespaceSpecifierAttr(std::get<2>(element).get());
        break;
      }
      default:
        LOG(FATAL) << "Unreachable code.";
    }
    mlir_specifiers_data.push_back(std::move(mlir_element));
  }
  auto mlir_specifiers = builder_.getArrayAttr(mlir_specifiers_data);
  JsirStringLiteralAttr mlir_source = VisitStringLiteralAttr(node->source());
  JsirImportAttributeAttr mlir_assertions;
  if (node->assertions().has_value()) {
    mlir_assertions = VisitImportAttributeAttr(node->assertions().value());
  }
  return CreateStmt<JsirImportDeclarationOp>(node, mlir_specifiers, mlir_source, mlir_assertions);
}

JsirExportNamedDeclarationOp AstToJsir::VisitExportNamedDeclaration(const JsExportNamedDeclaration *node) {
  std::vector<mlir::Attribute> mlir_specifiers_data;
  for (const auto &element : *node->specifiers()) {
    JsirExportSpecifierAttr mlir_element = VisitExportSpecifierAttr(element.get());
    mlir_specifiers_data.push_back(std::move(mlir_element));
  }
  auto mlir_specifiers = builder_.getArrayAttr(mlir_specifiers_data);
  JsirStringLiteralAttr mlir_source;
  if (node->source().has_value()) {
    mlir_source = VisitStringLiteralAttr(node->source().value());
  }
  mlir::ArrayAttr mlir_assertions;
  if (node->assertions().has_value()) {
    std::vector<mlir::Attribute> mlir_assertions_data;
    for (const auto &element : *node->assertions().value()) {
      JsirImportAttributeAttr mlir_element = VisitImportAttributeAttr(element.get());
      mlir_assertions_data.push_back(std::move(mlir_element));
    }
    mlir_assertions = builder_.getArrayAttr(mlir_assertions_data);
  }
  auto op = CreateStmt<JsirExportNamedDeclarationOp>(node, mlir_specifiers, mlir_source, mlir_assertions);
  if (node->declaration().has_value()) {
    mlir::Region &mlir_declaration_region = op.getDeclaration();
    AppendNewBlockAndPopulate(mlir_declaration_region, [&] {
      VisitDeclaration(node->declaration().value());
    });
  }
  return op;
}

JsirExportAllDeclarationOp AstToJsir::VisitExportAllDeclaration(const JsExportAllDeclaration *node) {
  JsirStringLiteralAttr mlir_source = VisitStringLiteralAttr(node->source());
  mlir::ArrayAttr mlir_assertions;
  if (node->assertions().has_value()) {
    std::vector<mlir::Attribute> mlir_assertions_data;
    for (const auto &element : *node->assertions().value()) {
      JsirImportAttributeAttr mlir_element = VisitImportAttributeAttr(element.get());
      mlir_assertions_data.push_back(std::move(mlir_element));
    }
    mlir_assertions = builder_.getArrayAttr(mlir_assertions_data);
  }
  return CreateStmt<JsirExportAllDeclarationOp>(node, mlir_source, mlir_assertions);
}

// clang-format on
// NOLINTEND(whitespace/line_length)
// IWYU pragma: end_keep

}  // namespace maldoca
